{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.onCut = onCut;\nexports.onPaste = onPaste;\nexports.onChange = onChange;\nexports.onKeyDown = onKeyDown;\n\nvar _edit = require('./edit');\n\nvar _edit2 = _interopRequireDefault(_edit);\n\nvar _parse3 = require('./parse');\n\nvar _parse4 = _interopRequireDefault(_parse3);\n\nvar _format2 = require('./format');\n\nvar _format3 = _interopRequireDefault(_format2);\n\nvar _dom = require('./dom');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction onCut(event, input, _parse, _format, on_change) {\n  // The actual cut hasn't happened just yet hence the timeout.\n  setTimeout(function () {\n    return format_input_text(input, _parse, _format, undefined, on_change);\n  }, 0);\n}\n\nfunction onPaste(event, input, _parse, _format, on_change) {\n  var selection = (0, _dom.getSelection)(input); // If selection is made,\n  // just erase the selected text\n  // prior to pasting\n\n  if (selection) {\n    erase_selection(input, selection);\n  }\n\n  format_input_text(input, _parse, _format, undefined, on_change);\n}\n\nfunction onChange(event, input, _parse, _format, on_change) {\n  format_input_text(input, _parse, _format, undefined, on_change);\n} // Intercepts \"Delete\" and \"Backspace\" keys.\n// (hitting \"Delete\" or \"Backspace\" at any caret\n//  position should always result in rasing a digit)\n\n\nfunction onKeyDown(event, input, _parse, _format, on_change) {\n  var operation = (0, _dom.getOperation)(event);\n\n  switch (operation) {\n    case 'Delete':\n    case 'Backspace':\n      // Intercept this operation and perform it manually.\n      event.preventDefault();\n      var selection = (0, _dom.getSelection)(input); // If selection is made,\n      // just erase the selected text,\n      // and don't apply any more operations to it.\n\n      if (selection) {\n        erase_selection(input, selection);\n        return format_input_text(input, _parse, _format, undefined, on_change);\n      } // Else, perform the (character erasing) operation manually\n\n\n      return format_input_text(input, _parse, _format, operation, on_change);\n\n    default: // Will be handled when `onChange` fires.\n\n  }\n}\n/**\r\n * Erases the selected text inside an `<input/>`.\r\n * @param  {DOMElement} input\r\n * @param  {Selection} selection\r\n */\n\n\nfunction erase_selection(input, selection) {\n  var text = input.value;\n  text = text.slice(0, selection.start) + text.slice(selection.end);\n  input.value = text;\n  (0, _dom.setCaretPosition)(input, selection.start);\n}\n/**\r\n * Parses and re-formats `<input/>` textual value.\r\n * E.g. when a user enters something into the `<input/>`\r\n * that raw input must first be parsed and the re-formatted properly.\r\n * Is called either after some user input (e.g. entered a character, pasted something)\r\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\r\n * @param  {DOMElement} input\r\n * @param  {Function} parse\r\n * @param  {Function} format\r\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\r\n * @param  {Function} onChange\r\n */\n\n\nfunction format_input_text(input, _parse, _format, operation, on_change) {\n  // Parse `<input/>` textual value.\n  // Get `value` and `caret` position.\n  var _parse2 = (0, _parse4.default)(input.value, (0, _dom.getCaretPosition)(input), _parse),\n      value = _parse2.value,\n      caret = _parse2.caret; // If a user performed an operation (e.g. \"Backspace\", \"Delete\")\n  // then apply that operation and get new `value` and `caret` position.\n\n\n  if (operation) {\n    var operation_applied = (0, _edit2.default)(value, caret, operation);\n    value = operation_applied.value;\n    caret = operation_applied.caret;\n  } // Format the `value`.\n  // (and reposition the caret accordingly)\n\n\n  var formatted = (0, _format3.default)(value, caret, _format);\n  var text = formatted.text;\n  caret = formatted.caret; // Set `<input/>` textual value manually\n  // to prevent React from resetting the caret position\n  // later inside subsequent `render()`.\n  // Doesn't work for custom `inputComponent`s for some reason.\n\n  input.value = text; // Position the caret properly.\n\n  (0, _dom.setCaretPosition)(input, caret); // `<input/>` textual value may have changed,\n  // so the parsed `value` may have changed too.\n  // The `value` didn't neccessarily change\n  // but it might have.\n\n  on_change(value);\n} //# sourceMappingURL=input control.js.map","map":{"version":3,"sources":["/Users/danilkonovalov/my-app/node_modules/input-format/modules/input control.js"],"names":["Object","defineProperty","exports","value","onCut","onPaste","onChange","onKeyDown","_edit","require","_edit2","_interopRequireDefault","_parse3","_parse4","_format2","_format3","_dom","obj","__esModule","default","event","input","_parse","_format","on_change","setTimeout","format_input_text","undefined","selection","getSelection","erase_selection","operation","getOperation","preventDefault","text","slice","start","end","setCaretPosition","_parse2","getCaretPosition","caret","operation_applied","formatted"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.onCut = onCut;\nexports.onPaste = onPaste;\nexports.onChange = onChange;\nexports.onKeyDown = onKeyDown;\n\nvar _edit = require('./edit');\n\nvar _edit2 = _interopRequireDefault(_edit);\n\nvar _parse3 = require('./parse');\n\nvar _parse4 = _interopRequireDefault(_parse3);\n\nvar _format2 = require('./format');\n\nvar _format3 = _interopRequireDefault(_format2);\n\nvar _dom = require('./dom');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction onCut(event, input, _parse, _format, on_change) {\n\t// The actual cut hasn't happened just yet hence the timeout.\n\tsetTimeout(function () {\n\t\treturn format_input_text(input, _parse, _format, undefined, on_change);\n\t}, 0);\n}\n\nfunction onPaste(event, input, _parse, _format, on_change) {\n\tvar selection = (0, _dom.getSelection)(input);\n\n\t// If selection is made,\n\t// just erase the selected text\n\t// prior to pasting\n\tif (selection) {\n\t\terase_selection(input, selection);\n\t}\n\n\tformat_input_text(input, _parse, _format, undefined, on_change);\n}\n\nfunction onChange(event, input, _parse, _format, on_change) {\n\tformat_input_text(input, _parse, _format, undefined, on_change);\n}\n\n// Intercepts \"Delete\" and \"Backspace\" keys.\n// (hitting \"Delete\" or \"Backspace\" at any caret\n//  position should always result in rasing a digit)\nfunction onKeyDown(event, input, _parse, _format, on_change) {\n\tvar operation = (0, _dom.getOperation)(event);\n\n\tswitch (operation) {\n\t\tcase 'Delete':\n\t\tcase 'Backspace':\n\t\t\t// Intercept this operation and perform it manually.\n\t\t\tevent.preventDefault();\n\n\t\t\tvar selection = (0, _dom.getSelection)(input);\n\n\t\t\t// If selection is made,\n\t\t\t// just erase the selected text,\n\t\t\t// and don't apply any more operations to it.\n\t\t\tif (selection) {\n\t\t\t\terase_selection(input, selection);\n\t\t\t\treturn format_input_text(input, _parse, _format, undefined, on_change);\n\t\t\t}\n\n\t\t\t// Else, perform the (character erasing) operation manually\n\t\t\treturn format_input_text(input, _parse, _format, operation, on_change);\n\n\t\tdefault:\n\t\t// Will be handled when `onChange` fires.\n\t}\n}\n\n/**\r\n * Erases the selected text inside an `<input/>`.\r\n * @param  {DOMElement} input\r\n * @param  {Selection} selection\r\n */\nfunction erase_selection(input, selection) {\n\tvar text = input.value;\n\ttext = text.slice(0, selection.start) + text.slice(selection.end);\n\n\tinput.value = text;\n\t(0, _dom.setCaretPosition)(input, selection.start);\n}\n\n/**\r\n * Parses and re-formats `<input/>` textual value.\r\n * E.g. when a user enters something into the `<input/>`\r\n * that raw input must first be parsed and the re-formatted properly.\r\n * Is called either after some user input (e.g. entered a character, pasted something)\r\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\r\n * @param  {DOMElement} input\r\n * @param  {Function} parse\r\n * @param  {Function} format\r\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\r\n * @param  {Function} onChange\r\n */\nfunction format_input_text(input, _parse, _format, operation, on_change) {\n\t// Parse `<input/>` textual value.\n\t// Get `value` and `caret` position.\n\tvar _parse2 = (0, _parse4.default)(input.value, (0, _dom.getCaretPosition)(input), _parse),\n\t    value = _parse2.value,\n\t    caret = _parse2.caret;\n\n\t// If a user performed an operation (e.g. \"Backspace\", \"Delete\")\n\t// then apply that operation and get new `value` and `caret` position.\n\n\n\tif (operation) {\n\t\tvar operation_applied = (0, _edit2.default)(value, caret, operation);\n\n\t\tvalue = operation_applied.value;\n\t\tcaret = operation_applied.caret;\n\t}\n\n\t// Format the `value`.\n\t// (and reposition the caret accordingly)\n\tvar formatted = (0, _format3.default)(value, caret, _format);\n\n\tvar text = formatted.text;\n\tcaret = formatted.caret;\n\n\t// Set `<input/>` textual value manually\n\t// to prevent React from resetting the caret position\n\t// later inside subsequent `render()`.\n\t// Doesn't work for custom `inputComponent`s for some reason.\n\tinput.value = text;\n\t// Position the caret properly.\n\t(0, _dom.setCaretPosition)(input, caret);\n\n\t// `<input/>` textual value may have changed,\n\t// so the parsed `value` may have changed too.\n\t// The `value` didn't neccessarily change\n\t// but it might have.\n\ton_change(value);\n}\n//# sourceMappingURL=input control.js.map"]},"metadata":{},"sourceType":"script"}