{"ast":null,"code":"import isValidNumber from '../validate_';\nimport parseDigits from '../parseDigits';\nimport { startsWith, endsWith } from './util';\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\n\nexport default {\n  /**\r\n   * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n   */\n  POSSIBLE: function POSSIBLE(number, candidate, metadata) {\n    return true;\n  },\n\n  /**\r\n   * Phone numbers accepted are \"possible\" and \"valid\".\r\n   * Numbers written in national format must have their national-prefix\r\n   * present if it is usually written for a number of this type.\r\n   */\n  VALID: function VALID(number, candidate, metadata) {\n    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidate.toString(), metadata)) {\n      return false;\n    } // Skipped for simplicity.\n    // return isNationalPrefixPresentIfRequired(number, metadata)\n\n\n    return true;\n  },\n\n  /**\r\n   * Phone numbers accepted are \"valid\" and\r\n   * are grouped in a possible way for this locale. For example, a US number written as\r\n   * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n   * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol in the national significant number\r\n   * are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use,\r\n   * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n   */\n  STRICT_GROUPING: function STRICT_GROUPING(number, candidate, metadata, regExpCache) {\n    var candidateString = candidate.toString();\n\n    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString, metadata) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number, metadata)) {\n      return false;\n    }\n\n    return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);\n  },\n\n  /**\r\n   * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\r\n   * are grouped in the same way that we would have formatted it, or as a single block. For\r\n   * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\r\n   * \"650 253 0000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol are also dropped at this level.\r\n   * <p>\r\n   * Warning: This level might result in lower coverage especially for regions outside of country\r\n   * code \"+1\". If you are not sure about which level to use, email the discussion group\r\n   * libphonenumber-discuss@googlegroups.com.\r\n   */\n  EXACT_GROUPING: function EXACT_GROUPING(number, candidate, metadata, regExpCache) {\n    var candidateString = candidate.toString();\n\n    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString, metadata) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number, metadata)) {\n      return false;\n    }\n\n    return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);\n  }\n};\n\nfunction containsOnlyValidXChars(number, candidate, metadata) {\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\n  // national significant number or (2) an extension sign, in which case they always precede the\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\n  // or 'X'. We ignore the character if it appears as the last character of the string.\n  for (var index = 0; index < candidate.length - 1; index++) {\n    var charAtIndex = candidate.charAt(index);\n\n    if (charAtIndex === 'x' || charAtIndex === 'X') {\n      var charAtNextIndex = candidate.charAt(index + 1);\n\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {\n        // This is the carrier code case, in which the 'X's always precede the national\n        // significant number.\n        index++;\n\n        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH) {\n          return false;\n        } // This is the extension sign case, in which the 'x' or 'X' should always precede the\n        // extension number.\n\n      } else if (parseDigits(candidate.substring(index)) !== number.ext) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction isNationalPrefixPresentIfRequired(number, _metadata) {\n  // First, check how we deduced the country code. If it was written in international format, then\n  // the national prefix is not required.\n  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY') {\n    return true;\n  }\n\n  var phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode());\n  var metadata = util.getMetadataForRegion(phoneNumberRegion);\n\n  if (metadata == null) {\n    return true;\n  } // Check if a national prefix should be present when formatting this number.\n\n\n  var nationalNumber = util.getNationalSignificantNumber(number);\n  var formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber); // To do this, we check that a national prefix formatting rule was present\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\n\n  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0) {\n    if (formatRule.getNationalPrefixOptionalWhenFormatting()) {\n      // The national-prefix is optional in these cases, so we don't need to check if it was\n      // present.\n      return true;\n    }\n\n    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(formatRule.getNationalPrefixFormattingRule())) {\n      // National Prefix not needed for this number.\n      return true;\n    } // Normalize the remainder.\n\n\n    var rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput()); // Check if we found a national prefix and/or carrier code at the start of the raw input, and\n    // return the result.\n\n    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null);\n  }\n\n  return true;\n}\n\nexport function containsMoreThanOneSlashInNationalNumber(number, candidate) {\n  var firstSlashInBodyIndex = candidate.indexOf('/');\n\n  if (firstSlashInBodyIndex < 0) {\n    // No slashes, this is okay.\n    return false;\n  } // Now look for a second one.\n\n\n  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);\n\n  if (secondSlashInBodyIndex < 0) {\n    // Only one slash, this is okay.\n    return false;\n  } // If the first slash is after the country calling code, this is permitted.\n\n\n  var candidateHasCountryCode = number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN;\n\n  if (candidateHasCountryCode && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex)) === String(number.getCountryCode())) {\n    // Any more slashes and this is illegal.\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;\n  }\n\n  return true;\n}\n\nfunction checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {\n  var normalizedCandidate = normalizeDigits(candidate, true\n  /* keep non-digits */\n  );\n  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);\n\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n    return true;\n  } // If this didn't pass, see if there are any alternate formats that match, and try them instead.\n\n\n  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());\n  var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n\n  if (alternateFormats) {\n    for (var _iterator = alternateFormats.numberFormats(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var alternateFormat = _ref;\n\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\n        // There is only one leading digits pattern for alternate formats.\n        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);\n\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\n          // Leading digits don't match; try another one.\n          continue;\n        }\n      }\n\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);\n\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\n\n\nfunction getNationalNumberGroups(metadata, number, formattingPattern) {\n  if (formattingPattern) {\n    // We format the NSN only, and split that according to the separator.\n    var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');\n  } // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\n\n\n  var rfc3966Format = formatNumber(number, 'RFC3966', metadata); // We remove the extension part from the formatted string before splitting it into different\n  // groups.\n\n  var endIndex = rfc3966Format.indexOf(';');\n\n  if (endIndex < 0) {\n    endIndex = rfc3966Format.length;\n  } // The country-code will have a '-' following it.\n\n\n  var startIndex = rfc3966Format.indexOf('-') + 1;\n  return rfc3966Format.slice(startIndex, endIndex).split('-');\n}\n\nfunction allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN); // Set this to the last group, skipping it if the number has an extension.\n\n  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1; // First we check if the national significant number is formatted as a block.\n  // We use contains and not equals, since the national significant number may be present with\n  // a prefix such as a national number prefix, or the country code itself.\n\n  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {\n    return true;\n  } // Starting from the end, go through in reverse, excluding the first group, and check the\n  // candidate and number groups are the same.\n\n\n  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;\n\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {\n      return false;\n    }\n\n    formattedNumberGroupIndex--;\n    candidateNumberGroupIndex--;\n  } // Now check the first group. There may be a national prefix at the start, so we only check\n  // that the candidate group ends with the formatted number group.\n\n\n  return candidateNumberGroupIndex >= 0 && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);\n}\n\nfunction allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  var fromIndex = 0;\n\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {\n    // First skip the country code if the normalized candidate contained it.\n    var countryCode = String(number.getCountryCode());\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();\n  } // Check each group of consecutive digits are not broken into separate groupings in the\n  // {@code normalizedCandidate} string.\n\n\n  for (var i = 0; i < formattedNumberGroups.length; i++) {\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);\n\n    if (fromIndex < 0) {\n      return false;\n    } // Moves {@code fromIndex} forward.\n\n\n    fromIndex += formattedNumberGroups[i].length();\n\n    if (i == 0 && fromIndex < normalizedCandidate.length()) {\n      // We are at the position right after the NDC. We get the region used for formatting\n      // information based on the country code in the phone number, rather than the number itself,\n      // as we do not need to distinguish between different countries with the same country\n      // calling code and this is faster.\n      var region = util.getRegionCodeForCountryCode(number.getCountryCode());\n\n      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\n        // This means there is no formatting symbol after the NDC. In this case, we only\n        // accept the number if there is no formatting symbol at all in the number, except\n        // for extensions. This is only important for countries with national prefixes.\n        var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n        return startsWith(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);\n      }\n    }\n  } // The check here makes sure that we haven't mistakenly already used the extension to\n  // match the last group of the subscriber number. Note the extension cannot have\n  // formatting in-between digits.\n\n\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());\n}","map":{"version":3,"sources":["../../source/findNumbers/Leniency.js"],"names":["POSSIBLE","VALID","isValidNumber","containsOnlyValidXChars","candidate","STRICT_GROUPING","candidateString","containsMoreThanOneSlashInNationalNumber","isNationalPrefixPresentIfRequired","checkNumberGroupingIsValid","EXACT_GROUPING","index","charAtIndex","charAtNextIndex","util","MatchType","parseDigits","number","phoneNumberRegion","metadata","nationalNumber","formatRule","PhoneNumberUtil","rawInputCopy","firstSlashInBodyIndex","secondSlashInBodyIndex","candidateHasCountryCode","CountryCodeSource","String","normalizedCandidate","normalizeDigits","formattedNumberGroups","getNationalNumberGroups","checkGroups","alternateFormats","MetadataManager","nationalSignificantNumber","alternateFormat","leadingDigitsRegExp","regExpCache","rfc3966Format","formatNumber","endIndex","startIndex","candidateGroups","candidateNumberGroupIndex","formattedNumberGroupIndex","endsWith","fromIndex","countryCode","i","region","Character","startsWith"],"mappings":"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","sourcesContent":["import isValidNumber from '../validate_'\r\nimport parseDigits from '../parseDigits'\r\n\r\nimport {\r\n\tstartsWith,\r\n\tendsWith\r\n} from './util'\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport default\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(number, candidate, metadata)\r\n\t{\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(number, candidate, metadata)\r\n\t{\r\n\t\tif (!isValidNumber(number, undefined, metadata) ||\r\n\t\t\t!containsOnlyValidXChars(number, candidate.toString(), metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n    // Skipped for simplicity.\r\n\t\t// return isNationalPrefixPresentIfRequired(number, metadata)\r\n    return true\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(number, candidate, metadata, regExpCache)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, undefined, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped,\r\n\t\t\tregExpCache\r\n\t\t)\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\r\n\t * are grouped in the same way that we would have formatted it, or as a single block. For\r\n\t * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t * <p>\r\n\t * Warning: This level might result in lower coverage especially for regions outside of country\r\n\t * code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(number, candidate, metadata, regExpCache)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, undefined, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsAreExactlyPresent,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t}\r\n}\r\n\r\nfunction containsOnlyValidXChars(number, candidate, metadata)\r\n{\r\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\r\n  // national significant number or (2) an extension sign, in which case they always precede the\r\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\r\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\r\n  // or 'X'. We ignore the character if it appears as the last character of the string.\r\n  for (let index = 0; index < candidate.length - 1; index++)\r\n  {\r\n    const charAtIndex = candidate.charAt(index)\r\n\r\n    if (charAtIndex === 'x' || charAtIndex === 'X')\r\n    {\r\n      const charAtNextIndex = candidate.charAt(index + 1)\r\n\r\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X')\r\n      {\r\n        // This is the carrier code case, in which the 'X's always precede the national\r\n        // significant number.\r\n        index++\r\n        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH)\r\n        {\r\n          return false\r\n        }\r\n\t      // This is the extension sign case, in which the 'x' or 'X' should always precede the\r\n\t      // extension number.\r\n      }\r\n      else if (parseDigits(candidate.substring(index)) !== number.ext)\r\n      {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction isNationalPrefixPresentIfRequired(number, _metadata)\r\n{\r\n  // First, check how we deduced the country code. If it was written in international format, then\r\n  // the national prefix is not required.\r\n  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY')\r\n  {\r\n    return true\r\n  }\r\n\r\n  const phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n\r\n  const metadata = util.getMetadataForRegion(phoneNumberRegion)\r\n  if (metadata == null)\r\n  {\r\n    return true\r\n  }\r\n\r\n  // Check if a national prefix should be present when formatting this number.\r\n  const nationalNumber = util.getNationalSignificantNumber(number)\r\n  const formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber)\r\n\r\n  // To do this, we check that a national prefix formatting rule was present\r\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\r\n  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0)\r\n  {\r\n    if (formatRule.getNationalPrefixOptionalWhenFormatting())\r\n    {\r\n      // The national-prefix is optional in these cases, so we don't need to check if it was\r\n      // present.\r\n      return true\r\n    }\r\n\r\n    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(\r\n        formatRule.getNationalPrefixFormattingRule()))\r\n    {\r\n      // National Prefix not needed for this number.\r\n      return true\r\n    }\r\n\r\n    // Normalize the remainder.\r\n    const rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput())\r\n\r\n    // Check if we found a national prefix and/or carrier code at the start of the raw input, and\r\n    // return the result.\r\n    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport function containsMoreThanOneSlashInNationalNumber(number, candidate)\r\n{\r\n  const firstSlashInBodyIndex = candidate.indexOf('/')\r\n  if (firstSlashInBodyIndex < 0)\r\n  {\r\n    // No slashes, this is okay.\r\n    return false\r\n  }\r\n\r\n  // Now look for a second one.\r\n  const secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\r\n  if (secondSlashInBodyIndex < 0)\r\n  {\r\n    // Only one slash, this is okay.\r\n    return false\r\n  }\r\n\r\n  // If the first slash is after the country calling code, this is permitted.\r\n  const candidateHasCountryCode =\r\n      (number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN\r\n       || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN)\r\n\r\n  if (candidateHasCountryCode\r\n      && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex))\r\n          === String(number.getCountryCode()))\r\n  {\r\n    // Any more slashes and this is illegal.\r\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction checkNumberGroupingIsValid(\r\n  number,\r\n  candidate,\r\n  metadata,\r\n  checkGroups,\r\n  regExpCache\r\n) {\r\n  const normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\r\n  let formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\r\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n    return true\r\n  }\r\n\r\n  // If this didn't pass, see if there are any alternate formats that match, and try them instead.\r\n  const alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\r\n  const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\r\n  if (alternateFormats) {\r\n    for (const alternateFormat of alternateFormats.numberFormats()) {\r\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\r\n        // There is only one leading digits pattern for alternate formats.\r\n        const leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0])\r\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\r\n          // Leading digits don't match; try another one.\r\n          continue\r\n        }\r\n      }\r\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\r\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\r\nfunction getNationalNumberGroups(\r\n\tmetadata,\r\n\tnumber,\r\n\tformattingPattern\r\n) {\r\n  if (formattingPattern) {\r\n    // We format the NSN only, and split that according to the separator.\r\n    const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n    return util.formatNsnUsingPattern(nationalSignificantNumber,\r\n                                      formattingPattern, 'RFC3966', metadata).split('-')\r\n\t}\r\n\r\n  // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\r\n  const rfc3966Format = formatNumber(number, 'RFC3966', metadata)\r\n\r\n  // We remove the extension part from the formatted string before splitting it into different\r\n  // groups.\r\n  let endIndex = rfc3966Format.indexOf(';')\r\n  if (endIndex < 0) {\r\n    endIndex = rfc3966Format.length\r\n  }\r\n\r\n  // The country-code will have a '-' following it.\r\n  const startIndex = rfc3966Format.indexOf('-') + 1\r\n  return rfc3966Format.slice(startIndex, endIndex).split('-')\r\n}\r\n\r\nfunction allNumberGroupsAreExactlyPresent\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n  const candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\r\n\r\n  // Set this to the last group, skipping it if the number has an extension.\r\n  let candidateNumberGroupIndex =\r\n      number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\r\n\r\n  // First we check if the national significant number is formatted as a block.\r\n  // We use contains and not equals, since the national significant number may be present with\r\n  // a prefix such as a national number prefix, or the country code itself.\r\n  if (candidateGroups.length == 1\r\n      || candidateGroups[candidateNumberGroupIndex].contains(\r\n          util.getNationalSignificantNumber(number)))\r\n  {\r\n    return true\r\n  }\r\n\r\n  // Starting from the end, go through in reverse, excluding the first group, and check the\r\n  // candidate and number groups are the same.\r\n  let formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\r\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\r\n  {\r\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\r\n    {\r\n      return false\r\n    }\r\n    formattedNumberGroupIndex--\r\n    candidateNumberGroupIndex--\r\n  }\r\n\r\n  // Now check the first group. There may be a national prefix at the start, so we only check\r\n  // that the candidate group ends with the formatted number group.\r\n  return (candidateNumberGroupIndex >= 0\r\n      && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\r\n}\r\n\r\n\r\nfunction allNumberGroupsRemainGrouped\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n  let fromIndex = 0\r\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\r\n  {\r\n    // First skip the country code if the normalized candidate contained it.\r\n    const countryCode = String(number.getCountryCode())\r\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\r\n  }\r\n\r\n  // Check each group of consecutive digits are not broken into separate groupings in the\r\n  // {@code normalizedCandidate} string.\r\n  for (let i = 0; i < formattedNumberGroups.length; i++)\r\n  {\r\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\r\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\r\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\r\n    if (fromIndex < 0) {\r\n      return false\r\n    }\r\n    // Moves {@code fromIndex} forward.\r\n    fromIndex += formattedNumberGroups[i].length()\r\n    if (i == 0 && fromIndex < normalizedCandidate.length())\r\n    {\r\n      // We are at the position right after the NDC. We get the region used for formatting\r\n      // information based on the country code in the phone number, rather than the number itself,\r\n      // as we do not need to distinguish between different countries with the same country\r\n      // calling code and this is faster.\r\n      const region = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n      if (util.getNddPrefixForRegion(region, true) != null\r\n          && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\r\n        // This means there is no formatting symbol after the NDC. In this case, we only\r\n        // accept the number if there is no formatting symbol at all in the number, except\r\n        // for extensions. This is only important for countries with national prefixes.\r\n        const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n        return startsWith\r\n        (\r\n      \t  normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\r\n           nationalSignificantNumber\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  // The check here makes sure that we haven't mistakenly already used the extension to\r\n  // match the last group of the subscriber number. Note the extension cannot have\r\n  // formatting in-between digits.\r\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension())\r\n}"]},"metadata":{},"sourceType":"module"}