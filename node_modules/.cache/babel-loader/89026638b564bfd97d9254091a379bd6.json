{"ast":null,"code":"// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\nimport { VALID_DIGITS, VALID_PUNCTUATION, PLUS_CHARS, MIN_LENGTH_FOR_NSN, MAX_LENGTH_FOR_NSN, MAX_LENGTH_COUNTRY_CODE } from './constants';\nimport { matchesEntirely } from './util';\nimport ParseError from './ParseError';\nimport Metadata from './metadata';\nimport isViablePhoneNumber from './isViablePhoneNumber';\nimport { extractExtension } from './extension';\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber';\nimport getCountryCallingCode from './getCountryCallingCode';\nimport getNumberType, { checkNumberLengthForType } from './getNumberType_';\nimport { is_possible_number } from './isPossibleNumber_';\nimport { stripIDDPrefix } from './IDD';\nimport { parseRFC3966 } from './RFC3966';\nimport PhoneNumber from './PhoneNumber'; // We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\n\nvar MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$'); // `options`:\n//  {\n//    country:\n//    {\n//      restrict - (a two-letter country code)\n//                 the phone number must be in this country\n//\n//      default - (a two-letter country code)\n//                default country to use for phone number parsing and validation\n//                (if no country code could be derived from the phone number)\n//    }\n//  }\n//\n// Returns `{ country, number }`\n//\n// Example use cases:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\nexport default function parse(text) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var metadata = arguments[2];\n  metadata = new Metadata(metadata); // Validate `defaultCountry`.\n\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    throw new Error('Unknown country: ' + options.defaultCountry);\n  } // Parse the phone number.\n\n\n  var _parse_input = parse_input(text, options.v2),\n      formattedPhoneNumber = _parse_input.number,\n      ext = _parse_input.ext; // If the phone number is not viable then return nothing.\n\n\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      throw new ParseError('NOT_A_NUMBER');\n    }\n\n    return {};\n  }\n\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, metadata),\n      country = _parsePhoneNumber.country,\n      nationalNumber = _parsePhoneNumber.nationalNumber,\n      countryCallingCode = _parsePhoneNumber.countryCallingCode,\n      carrierCode = _parsePhoneNumber.carrierCode;\n\n  if (!metadata.selectedCountry()) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    return {};\n  } // Validate national (significant) number length.\n\n\n  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new ParseError('TOO_SHORT');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new ParseError('TOO_LONG');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  }\n\n  if (options.v2) {\n    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);\n\n    if (country) {\n      phoneNumber.country = country;\n    }\n\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n\n    return phoneNumber;\n  } // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var valid = country && matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false;\n\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n/**\r\n * Extracts a parseable phone number.\r\n * @param  {string} text - Input.\r\n * @return {string}.\r\n */\n\nexport function extract_formatted_phone_number(text, v2) {\n  if (!text) {\n    return;\n  }\n\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (v2) {\n      throw new ParseError('TOO_LONG');\n    }\n\n    return;\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var starts_at = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (starts_at < 0) {\n    return;\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(starts_at) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n} // Strips any national prefix (such as 0, 1) present in the number provided.\n// \"Carrier codes\" are only used  in Colombia and Brazil,\n// and only when dialing within those countries from a mobile phone to a fixed line number.\n\nexport function strip_national_prefix_and_carrier_code(number, metadata) {\n  if (!number || !metadata.nationalPrefixForParsing()) {\n    return {\n      number: number\n    };\n  } // In many countries the national prefix\n  // is not just a constant digit (like `0` in UK)\n  // but can be different depending on the phone number\n  // (and can be also absent for some phone numbers).\n  //\n  // So `national_prefix_for_parsing` is used when parsing\n  // a national-prefixed (local) phone number\n  // into a national significant phone number\n  // extracting that possible national prefix out of it.\n  //\n  // Example `national_prefix_for_parsing` for Australia (AU) is `0|(183[12])`.\n  // Which means that in Australia the national prefix can be: `0`, `1831`, `1832`.\n  // Attempt to parse the first digits as a national prefix\n\n\n  var national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')');\n  var national_prefix_matcher = national_prefix_pattern.exec(number); // If no national prefix is present in the phone number,\n  // but the national prefix is optional for this country,\n  // then consider this phone number valid.\n  //\n  // Google's reference `libphonenumber` implementation\n  // wouldn't recognize such phone numbers as valid,\n  // but I think it would perfectly make sense\n  // to consider such phone numbers as valid\n  // because if a national phone number was originally\n  // formatted without the national prefix\n  // then it must be parseable back into the original national number.\n  // In other words, `parse(format(number))`\n  // must always be equal to `number`.\n  //\n\n  if (!national_prefix_matcher) {\n    return {\n      number: number\n    };\n  }\n\n  var national_significant_number = void 0; // In more complex cases just `national_prefix_for_parsing` regexp\n  // is not enough to extract the national number and then strip it\n  // like `number.slice(national_prefix.length)` because when parsing\n  // national numbers it's not always clear whether the first digits\n  // are a national prefix or part of the national significant number.\n  // For such cases `national_prefix_transform_rule` regexp is present\n  // which contains \"capturing groups\" that are later used in such\n  // `national_prefix_transform_rule` to transform the national number\n  // being parsed into the national significant number.\n  //\n  // Example.\n  // Country: U.S. Virgin Islands (VI).\n  // Country calling code: +1.\n  // Leading digits: 340.\n  // Phone number format: +1 (340) xxx-xxxx.\n  // National prefix: 1.\n  // National prefix for parsing: 1|([2-9]\\d{6})$.\n  // National prefix transform rule: 340$1.\n  //\n  // So for input \"13401234567\" \"national prefix for parsing\" regexp\n  // will return \"1\" and the national significant number will be\n  // \"13401234567\".slice(\"1\".length) === \"(340) 123-4567\".\n  //\n  // And for input \"3401234567\" \"national prefix for parsing\" regexp\n  // the \"captured group\" will be \"3401234567\" and the national significant\n  // number will be \"3401234567\".replace(\"340123\", \"340340123\") === \"(340) 3401234567\".\n  //\n  // `national_prefix_matcher[captured_groups_count]` means that\n  // the corresponding \"captured group\" is not empty.\n  // It can be empty if the regexp either doesn't have any \"capturing groups\"\n  // or if the \"capturing groups\" are defined as optional.\n  // Example: \"0?(?:...)?\" for Argentina.\n  //\n\n  var captured_groups_count = national_prefix_matcher.length - 1;\n\n  if (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count]) {\n    national_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule());\n  } // If it's a simple-enough case then just strip the national prefix from the number.\n  else {\n      // National prefix is the whole substring matched by\n      // the `national_prefix_for_parsing` regexp.\n      var national_prefix = national_prefix_matcher[0];\n      national_significant_number = number.slice(national_prefix.length);\n    }\n\n  var carrierCode = void 0;\n\n  if (captured_groups_count > 0) {\n    carrierCode = national_prefix_matcher[1];\n  } // The following is done in `get_country_and_national_number_for_local_number()` instead.\n  //\n  // // Verify the parsed national (significant) number for this country\n  // const national_number_rule = new RegExp(metadata.nationalNumberPattern())\n  // //\n  // // If the original number (before stripping national prefix) was viable,\n  // // and the resultant number is not, then prefer the original phone number.\n  // // This is because for some countries (e.g. Russia) the same digit could be both\n  // // a national prefix and a leading digit of a valid national phone number,\n  // // like `8` is the national prefix for Russia and both\n  // // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n  // if (matchesEntirely(number, national_number_rule) &&\n  // \t\t!matchesEntirely(national_significant_number, national_number_rule))\n  // {\n  // \treturn number\n  // }\n  // Return the parsed national (significant) number\n\n\n  return {\n    number: national_significant_number,\n    carrierCode: carrierCode\n  };\n}\nexport function find_country_code(country_calling_code, national_phone_number, metadata) {\n  // Is always non-empty, because `country_calling_code` is always valid\n  var possible_countries = metadata.countryCallingCodes()[country_calling_code]; // If there's just one country corresponding to the country code,\n  // then just return it, without further phone number digits validation.\n\n  if (possible_countries.length === 1) {\n    return possible_countries[0];\n  }\n\n  return _find_country_code(possible_countries, national_phone_number, metadata.metadata);\n} // Changes `metadata` `country`.\n\nfunction _find_country_code(possible_countries, national_phone_number, metadata) {\n  metadata = new Metadata(metadata);\n\n  for (var _iterator = possible_countries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var country = _ref;\n    metadata.country(country); // Leading digits check would be the simplest one\n\n    if (metadata.leadingDigits()) {\n      if (national_phone_number && national_phone_number.search(metadata.leadingDigits()) === 0) {\n        return country;\n      }\n    } // Else perform full validation with all of those\n    // fixed-line/mobile/etc regular expressions.\n    else if (getNumberType({\n        phone: national_phone_number,\n        country: country\n      }, undefined, metadata.metadata)) {\n        return country;\n      }\n  }\n}\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\n\nfunction parse_input(text, v2) {\n  // Parse RFC 3966 phone number URI.\n  if (text && text.indexOf('tel:') === 0) {\n    return parseRFC3966(text);\n  }\n\n  var number = extract_formatted_phone_number(text, v2); // If the phone number is not viable, then abort.\n\n  if (!number || !isViablePhoneNumber(number)) {\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var with_extension_stripped = extractExtension(number);\n\n  if (with_extension_stripped.ext) {\n    return with_extension_stripped;\n  }\n\n  return {\n    number: number\n  };\n}\n/**\r\n * Creates `parse()` result object.\r\n */\n\n\nfunction result(country, national_number, ext) {\n  var result = {\n    country: country,\n    phone: national_number\n  };\n\n  if (ext) {\n    result.ext = ext;\n  }\n\n  return result;\n}\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber\r\n * @param {string} [defaultCountry]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\n\n\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, metadata) {\n  var _extractCountryCallin = extractCountryCallingCode(formattedPhoneNumber, defaultCountry, metadata.metadata),\n      countryCallingCode = _extractCountryCallin.countryCallingCode,\n      number = _extractCountryCallin.number;\n\n  var country = void 0;\n\n  if (countryCallingCode) {\n    metadata.chooseCountryByCountryCallingCode(countryCallingCode);\n  } // If `formattedPhoneNumber` is in \"national\" format\n  // then `number` is defined and `countryCallingCode` isn't.\n  else if (number && defaultCountry) {\n      metadata.country(defaultCountry);\n      country = defaultCountry;\n      countryCallingCode = getCountryCallingCode(defaultCountry, metadata.metadata);\n    } else return {};\n\n  if (!number) {\n    return {\n      countryCallingCode: countryCallingCode\n    };\n  }\n\n  var _parseNationalNumber = parseNationalNumber(number, metadata),\n      nationalNumber = _parseNationalNumber.nationalNumber,\n      carrierCode = _parseNationalNumber.carrierCode; // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n\n\n  var exactCountry = find_country_code(countryCallingCode, nationalNumber, metadata);\n\n  if (exactCountry) {\n    country = exactCountry;\n    metadata.country(country);\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n\nfunction parseNationalNumber(number, metadata) {\n  var nationalNumber = parseIncompletePhoneNumber(number);\n  var carrierCode = void 0; // Parsing national prefixes and carrier codes\n  // is only required for local phone numbers\n  // but some people don't understand that\n  // and sometimes write international phone numbers\n  // with national prefixes (or maybe even carrier codes).\n  // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\n  // Google's original library forgives such mistakes\n  // and so does this library, because it has been requested:\n  // https://github.com/catamphetamine/libphonenumber-js/issues/127\n\n  var _strip_national_prefi = strip_national_prefix_and_carrier_code(nationalNumber, metadata),\n      potentialNationalNumber = _strip_national_prefi.number,\n      potentialCarrierCode = _strip_national_prefi.carrierCode; // If metadata has \"possible lengths\" then employ the new algorythm.\n\n\n  if (metadata.possibleLengths()) {\n    // We require that the NSN remaining after stripping the national prefix and\n    // carrier code be long enough to be a possible length for the region.\n    // Otherwise, we don't do the stripping, since the original number could be\n    // a valid short number.\n    switch (checkNumberLengthForType(potentialNationalNumber, undefined, metadata)) {\n      case 'TOO_SHORT': // case 'IS_POSSIBLE_LOCAL_ONLY':\n\n      case 'INVALID_LENGTH':\n        break;\n\n      default:\n        nationalNumber = potentialNationalNumber;\n        carrierCode = potentialCarrierCode;\n    }\n  } else {\n    // If the original number (before stripping national prefix) was viable,\n    // and the resultant number is not, then prefer the original phone number.\n    // This is because for some countries (e.g. Russia) the same digit could be both\n    // a national prefix and a leading digit of a valid national phone number,\n    // like `8` is the national prefix for Russia and both\n    // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n    if (matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) && !matchesEntirely(potentialNationalNumber, metadata.nationalNumberPattern())) {// Keep the number without stripping national prefix.\n    } else {\n      nationalNumber = potentialNationalNumber;\n      carrierCode = potentialCarrierCode;\n    }\n  }\n\n  return {\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n} // Determines the country for a given (possibly incomplete) phone number.\n// export function get_country_from_phone_number(number, metadata)\n// {\n// \treturn parsePhoneNumber(number, null, metadata).country\n// }\n// Parses a formatted phone number\n// and returns `{ countryCallingCode, number }`\n// where `number` is just the \"number\" part\n// which is left after extracting `countryCallingCode`\n// and is not necessarily a \"national (significant) number\"\n// and might as well contain national prefix.\n//\n\n\nexport function extractCountryCallingCode(number, country, metadata) {\n  number = parseIncompletePhoneNumber(number);\n\n  if (!number) {\n    return {};\n  } // If this is not an international phone number,\n  // then don't extract country phone code.\n\n\n  if (number[0] !== '+') {\n    // Convert an \"out-of-country\" dialing phone number\n    // to a proper international phone number.\n    var numberWithoutIDD = stripIDDPrefix(number, country, metadata); // If an IDD prefix was stripped then\n    // convert the number to international one\n    // for subsequent parsing.\n\n    if (numberWithoutIDD && numberWithoutIDD !== number) {\n      number = '+' + numberWithoutIDD;\n    } else {\n      return {\n        number: number\n      };\n    }\n  } // Fast abortion: country codes do not begin with a '0'\n\n\n  if (number[1] === '0') {\n    return {};\n  }\n\n  metadata = new Metadata(metadata); // The thing with country phone codes\n  // is that they are orthogonal to each other\n  // i.e. there's no such country phone code A\n  // for which country phone code B exists\n  // where B starts with A.\n  // Therefore, while scanning digits,\n  // if a valid country code is found,\n  // that means that it is the country code.\n  //\n\n  var i = 2;\n\n  while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\n    var countryCallingCode = number.slice(1, i);\n\n    if (metadata.countryCallingCodes()[countryCallingCode]) {\n      return {\n        countryCallingCode: countryCallingCode,\n        number: number.slice(i)\n      };\n    }\n\n    i++;\n  }\n\n  return {};\n}","map":{"version":3,"sources":["../source/parse_.js"],"names":["MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","options","metadata","formattedPhoneNumber","ext","parse_input","country","nationalNumber","countryCallingCode","carrierCode","parsePhoneNumber","phoneNumber","valid","matchesEntirely","result","possible","is_possible_number","phone","text","starts_at","number","national_prefix_pattern","national_prefix_matcher","national_significant_number","captured_groups_count","national_prefix","possible_countries","_find_country_code","national_phone_number","getNumberType","parseRFC3966","extract_formatted_phone_number","isViablePhoneNumber","with_extension_stripped","extractExtension","national_number","extractCountryCallingCode","getCountryCallingCode","parseNationalNumber","exactCountry","find_country_code","parseIncompletePhoneNumber","potentialNationalNumber","potentialCarrierCode","strip_national_prefix_and_carrier_code","checkNumberLengthForType","numberWithoutIDD","stripIDDPrefix","i"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_COUNTRY_CODE\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './isViablePhoneNumber'\r\nimport { extractExtension } from './extension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport getNumberType, { checkNumberLengthForType } from './getNumberType_'\r\nimport { is_possible_number } from './isPossibleNumber_'\r\nimport { stripIDDPrefix } from './IDD'\r\nimport { parseRFC3966 } from './RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options = {}, metadata)\r\n{\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parse_input(text, options.v2)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber)\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst\r\n\t{\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t}\r\n\t= parsePhoneNumber\r\n\t(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.selectedCountry()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2)\r\n\t{\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = country && matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false\r\n\r\n\tif (!options.extended)\r\n\t{\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),\r\n\t\tphone : nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number.\r\n * @param  {string} text - Input.\r\n * @return {string}.\r\n */\r\nexport function extract_formatted_phone_number(text, v2)\r\n{\r\n\tif (!text)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\tif (v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided.\r\n// \"Carrier codes\" are only used  in Colombia and Brazil,\r\n// and only when dialing within those countries from a mobile phone to a fixed line number.\r\nexport function strip_national_prefix_and_carrier_code(number, metadata)\r\n{\r\n\tif (!number || !metadata.nationalPrefixForParsing())\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// In many countries the national prefix\r\n\t// is not just a constant digit (like `0` in UK)\r\n\t// but can be different depending on the phone number\r\n\t// (and can be also absent for some phone numbers).\r\n\t//\r\n\t// So `national_prefix_for_parsing` is used when parsing\r\n\t// a national-prefixed (local) phone number\r\n\t// into a national significant phone number\r\n\t// extracting that possible national prefix out of it.\r\n\t//\r\n\t// Example `national_prefix_for_parsing` for Australia (AU) is `0|(183[12])`.\r\n\t// Which means that in Australia the national prefix can be: `0`, `1831`, `1832`.\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\tlet national_significant_number\r\n\r\n\t// In more complex cases just `national_prefix_for_parsing` regexp\r\n\t// is not enough to extract the national number and then strip it\r\n\t// like `number.slice(national_prefix.length)` because when parsing\r\n\t// national numbers it's not always clear whether the first digits\r\n\t// are a national prefix or part of the national significant number.\r\n\t// For such cases `national_prefix_transform_rule` regexp is present\r\n\t// which contains \"capturing groups\" that are later used in such\r\n\t// `national_prefix_transform_rule` to transform the national number\r\n\t// being parsed into the national significant number.\r\n\t//\r\n\t// Example.\r\n\t// Country: U.S. Virgin Islands (VI).\r\n\t// Country calling code: +1.\r\n\t// Leading digits: 340.\r\n\t// Phone number format: +1 (340) xxx-xxxx.\r\n\t// National prefix: 1.\r\n\t// National prefix for parsing: 1|([2-9]\\d{6})$.\r\n\t// National prefix transform rule: 340$1.\r\n\t//\r\n\t// So for input \"13401234567\" \"national prefix for parsing\" regexp\r\n\t// will return \"1\" and the national significant number will be\r\n\t// \"13401234567\".slice(\"1\".length) === \"(340) 123-4567\".\r\n\t//\r\n\t// And for input \"3401234567\" \"national prefix for parsing\" regexp\r\n\t// the \"captured group\" will be \"3401234567\" and the national significant\r\n\t// number will be \"3401234567\".replace(\"340123\", \"340340123\") === \"(340) 3401234567\".\r\n\t//\r\n\t// `national_prefix_matcher[captured_groups_count]` means that\r\n\t// the corresponding \"captured group\" is not empty.\r\n\t// It can be empty if the regexp either doesn't have any \"capturing groups\"\r\n\t// or if the \"capturing groups\" are defined as optional.\r\n\t// Example: \"0?(?:...)?\" for Argentina.\r\n\t//\r\n\tconst captured_groups_count = national_prefix_matcher.length - 1\r\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\r\n\t}\r\n\t// If it's a simple-enough case then just strip the national prefix from the number.\r\n\telse\r\n\t{\r\n\t\t// National prefix is the whole substring matched by\r\n\t\t// the `national_prefix_for_parsing` regexp.\r\n\t\tconst national_prefix = national_prefix_matcher[0]\r\n\t\tnational_significant_number = number.slice(national_prefix.length)\r\n\t}\r\n\r\n\tlet carrierCode\r\n\tif (captured_groups_count > 0)\r\n\t{\r\n\t\tcarrierCode = national_prefix_matcher[1]\r\n\t}\r\n\r\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\r\n\t//\r\n\t// // Verify the parsed national (significant) number for this country\r\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\r\n\t// //\r\n\t// // If the original number (before stripping national prefix) was viable,\r\n\t// // and the resultant number is not, then prefer the original phone number.\r\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// // a national prefix and a leading digit of a valid national phone number,\r\n\t// // like `8` is the national prefix for Russia and both\r\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t// if (matchesEntirely(number, national_number_rule) &&\r\n\t// \t\t!matchesEntirely(national_significant_number, national_number_rule))\r\n\t// {\r\n\t// \treturn number\r\n\t// }\r\n\r\n\t// Return the parsed national (significant) number\r\n   return {\r\n   \tnumber: national_significant_number,\r\n   \tcarrierCode\r\n   }\r\n}\r\n\r\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_calling_code` is always valid\r\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\r\n{\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tfor (const country of possible_countries)\r\n\t{\r\n\t\tmetadata.country(country)\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits())\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: national_phone_number, country }, undefined, metadata.metadata))\r\n\t\t{\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parse_input(text, v2)\r\n{\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0)\r\n\t{\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\r\n\tlet number = extract_formatted_phone_number(text, v2)\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = extractExtension(number)\r\n\tif (with_extension_stripped.ext)\r\n\t{\r\n\t\treturn with_extension_stripped\r\n\t}\r\n\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, national_number, ext)\r\n{\r\n\tconst result =\r\n\t{\r\n\t\tcountry,\r\n\t\tphone : national_number\r\n\t}\r\n\r\n\tif (ext)\r\n\t{\r\n\t\tresult.ext = ext\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber\r\n * @param {string} [defaultCountry]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, metadata)\r\n{\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tformattedPhoneNumber,\r\n\t\tdefaultCountry,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\tlet country\r\n\r\n\tif (countryCallingCode)\r\n\t{\r\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && defaultCountry)\r\n\t{\r\n\t\tmetadata.country(defaultCountry)\r\n\t\tcountry = defaultCountry\r\n\t\tcountryCallingCode = getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst { nationalNumber, carrierCode } = parseNationalNumber(number, metadata)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = find_country_code(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry)\r\n\t{\r\n\t\tcountry = exactCountry\r\n\t\tmetadata.country(country)\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\nfunction parseNationalNumber(number, metadata)\r\n{\r\n\tlet nationalNumber = parseIncompletePhoneNumber(number)\r\n\tlet carrierCode\r\n\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tnumber: potentialNationalNumber,\r\n\t\tcarrierCode: potentialCarrierCode\r\n\t} = strip_national_prefix_and_carrier_code(nationalNumber, metadata)\r\n\r\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\r\n\tif (metadata.possibleLengths())\r\n\t{\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tswitch (checkNumberLengthForType(potentialNationalNumber, undefined, metadata))\r\n\t\t{\r\n\t\t\tcase 'TOO_SHORT':\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tnationalNumber = potentialNationalNumber\r\n\t\t\t\tcarrierCode = potentialCarrierCode\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t// like `8` is the national prefix for Russia and both\r\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\tif (matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matchesEntirely(potentialNationalNumber, metadata.nationalNumberPattern()))\r\n\t\t{\r\n\t\t\t// Keep the number without stripping national prefix.\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnationalNumber = potentialNationalNumber\r\n\t\t\tcarrierCode = potentialCarrierCode\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\n// Determines the country for a given (possibly incomplete) phone number.\r\n// export function get_country_from_phone_number(number, metadata)\r\n// {\r\n// \treturn parsePhoneNumber(number, null, metadata).country\r\n// }\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ countryCallingCode, number }`\r\n// where `number` is just the \"number\" part\r\n// which is left after extracting `countryCallingCode`\r\n// and is not necessarily a \"national (significant) number\"\r\n// and might as well contain national prefix.\r\n//\r\nexport function extractCountryCallingCode(number, country, metadata)\r\n{\r\n\tnumber = parseIncompletePhoneNumber(number)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+')\r\n\t{\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, metadata)\r\n\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\treturn { number }\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0')\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\r\n\t{\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\r\n\t\tif (metadata.countryCallingCodes()[countryCallingCode])\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}