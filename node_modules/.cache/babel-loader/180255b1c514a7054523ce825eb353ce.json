{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // This is an enhanced port of Google Android `libphonenumber`'s\n// `asyoutypeformatter.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\n//\n// Simplified: does not differentiate between \"local-only\" numbers\n// and \"internationally dialable\" numbers.\n// For example, doesn't include changes like this:\n// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935\n\n\nimport Metadata from './metadata';\nimport PhoneNumber from './PhoneNumber';\nimport { VALID_DIGITS, VALID_PUNCTUATION, PLUS_CHARS } from './constants';\nimport { matchesEntirely } from './util';\nimport { extractCountryCallingCode as _extractCountryCallingCode, extract_formatted_phone_number, find_country_code, strip_national_prefix_and_carrier_code } from './parse_';\nimport { FIRST_GROUP_PATTERN, format_national_number_using_format, changeInternationalFormatStyle } from './format_';\nimport { checkNumberLengthForType } from './getNumberType_';\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'; // Used in phone number format template creation.\n// Could be any digit, I guess.\n\nvar DUMMY_DIGIT = '9'; // I don't know why is it exactly `15`\n\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15; // Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\n\nvar LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH); // The digits that have not been entered yet will be represented by a \\u2008,\n// the punctuation space.\n\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\n\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER); // Deprecated: Google has removed some formatting pattern related code from their repo.\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\n// Because this library supports generating custom metadata\n// some users may still be using old metadata so the relevant\n// code seems to stay until some next major version update.\n\nvar SUPPORT_LEGACY_FORMATTING_PATTERNS = true; // A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\n\nvar CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\[([^\\[\\]])*\\]/g;\n}; // Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\n\n\nvar CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\d(?=[^,}][^,}])/g;\n}; // A pattern that is used to determine if a `format` is eligible\n// to be used by the \"as you type formatter\".\n// It is eligible when the `format` contains groups of the dollar sign\n// followed by a single digit, separated by valid phone number punctuation.\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\n// getting into the output of the \"as you type formatter\".\n\n\nvar ELIGIBLE_FORMAT_PATTERN = new RegExp('^' + '[' + VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' + '$'); // This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\n\nvar MIN_LEADING_DIGITS_LENGTH = 3;\nvar VALID_INCOMPLETE_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\nvar VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i');\n\nvar AsYouType = function () {\n  /**\r\n   * @param {string?} [defaultCountry] - The default country used for parsing non-international phone numbers.\r\n   * @param {Object} metadata\r\n   */\n  function AsYouType(defaultCountry, metadata) {\n    _classCallCheck(this, AsYouType);\n\n    this.options = {};\n    this.metadata = new Metadata(metadata);\n\n    if (defaultCountry && this.metadata.hasCountry(defaultCountry)) {\n      this.defaultCountry = defaultCountry;\n    }\n\n    this.reset();\n  } // Not setting `options` to a constructor argument\n  // not to break backwards compatibility\n  // for older versions of the library.\n\n\n  _createClass(AsYouType, [{\n    key: 'input',\n    value: function input(text) {\n      // Parse input\n      var extracted_number = extract_formatted_phone_number(text) || ''; // Special case for a lone '+' sign\n      // since it's not considered a possible phone number.\n\n      if (!extracted_number) {\n        if (text && text.indexOf('+') >= 0) {\n          extracted_number = '+';\n        }\n      } // Validate possible first part of a phone number\n\n\n      if (!VALID_INCOMPLETE_PHONE_NUMBER_PATTERN.test(extracted_number)) {\n        return this.currentOutput;\n      }\n\n      return this.processInput(parseIncompletePhoneNumber(extracted_number));\n    }\n  }, {\n    key: 'processInput',\n    value: function processInput(input) {\n      // If an out of position '+' sign detected\n      // (or a second '+' sign),\n      // then just drop it from the input.\n      if (input[0] === '+') {\n        if (!this.parsedInput) {\n          this.parsedInput += '+'; // If a default country was set\n          // then reset it because an explicitly international\n          // phone number is being entered\n\n          this.resetCountriness();\n        }\n\n        input = input.slice(1);\n      } // Raw phone number\n\n\n      this.parsedInput += input; // // Reset phone number validation state\n      // this.valid = false\n      // Add digits to the national number\n\n      this.nationalNumber += input; // TODO: Deprecated: rename `this.nationalNumber`\n      // to `this.nationalNumber` and remove `.getNationalNumber()`.\n      // Try to format the parsed input\n\n      if (this.isInternational()) {\n        if (!this.countryCallingCode) {\n          // Extract country calling code from the digits entered so far.\n          // There must be some digits in order to extract anything from them.\n          if (!this.nationalNumber) {\n            // Return raw phone number\n            return this.parsedInput;\n          } // If one looks at country phone codes\n          // then he can notice that no one country phone code\n          // is ever a (leftmost) substring of another country phone code.\n          // So if a valid country code is extracted so far\n          // then it means that this is the country code.\n          // If no country phone code could be extracted so far,\n          // then just return the raw phone number,\n          // because it has no way of knowing\n          // how to format the phone number so far.\n\n\n          if (!this.extractCountryCallingCode()) {\n            // Return raw phone number\n            return this.parsedInput;\n          } // Initialize country-specific data\n\n\n          this.initialize_phone_number_formats_for_this_country_calling_code();\n          this.resetFormat();\n          this.determineTheCountry();\n        } // `this.country` could be `undefined`,\n        // for instance, when there is ambiguity\n        // in a form of several different countries\n        // each corresponding to the same country phone code\n        // (e.g. NANPA: USA, Canada, etc),\n        // and there's not enough digits entered\n        // to reliably determine the country\n        // the phone number belongs to.\n        // Therefore, in cases of such ambiguity,\n        // each time something is input,\n        // try to determine the country\n        // (if it's not determined yet).\n        else if (!this.country) {\n            this.determineTheCountry();\n          }\n      } else {\n        // Some national prefixes are substrings of other national prefixes\n        // (for the same country), therefore try to extract national prefix each time\n        // because a longer national prefix might be available at some point in time.\n        var previous_national_prefix = this.nationalPrefix;\n        this.nationalNumber = this.nationalPrefix + this.nationalNumber; // Possibly extract a national prefix\n\n        this.extractNationalPrefix();\n\n        if (this.nationalPrefix !== previous_national_prefix) {\n          // National number has changed\n          // (due to another national prefix been extracted)\n          // therefore national number has changed\n          // therefore reset all previous formatting data.\n          // (and leading digits matching state)\n          this.matching_formats = undefined;\n          this.resetFormat();\n        }\n      } // if (!this.shouldFormat())\n      // {\n      // \treturn this.format_as_non_formatted_number()\n      // }\n\n\n      if (!this.nationalNumber) {\n        return this.format_as_non_formatted_number();\n      } // Check the available phone number formats\n      // based on the currently available leading digits.\n\n\n      this.match_formats_by_leading_digits(); // Format the phone number (given the next digits)\n\n      var formatted_national_phone_number = this.formatNationalNumber(input); // If the phone number could be formatted,\n      // then return it, possibly prepending with country phone code\n      // (for international phone numbers only)\n\n      if (formatted_national_phone_number) {\n        return this.formatFullNumber(formatted_national_phone_number);\n      } // If the phone number couldn't be formatted,\n      // then just fall back to the raw phone number.\n\n\n      return this.format_as_non_formatted_number();\n    }\n  }, {\n    key: 'format_as_non_formatted_number',\n    value: function format_as_non_formatted_number() {\n      // Strip national prefix for incorrectly inputted international phones.\n      if (this.isInternational() && this.countryCallingCode) {\n        return '+' + this.countryCallingCode + this.nationalNumber;\n      }\n\n      return this.parsedInput;\n    }\n  }, {\n    key: 'formatNationalNumber',\n    value: function formatNationalNumber(next_digits) {\n      // Format the next phone number digits\n      // using the previously chosen phone number format.\n      //\n      // This is done here because if `attempt_to_format_complete_phone_number`\n      // was placed before this call then the `template`\n      // wouldn't reflect the situation correctly (and would therefore be inconsistent)\n      //\n      var national_number_formatted_with_previous_format = void 0;\n\n      if (this.chosenFormat) {\n        national_number_formatted_with_previous_format = this.formatNextNationalNumberDigits(next_digits);\n      } // See if the input digits can be formatted properly already. If not,\n      // use the results from formatNextNationalNumberDigits(), which does formatting\n      // based on the formatting pattern chosen.\n\n\n      var formatted_number = this.attempt_to_format_complete_phone_number(); // Just because a phone number doesn't have a suitable format\n      // that doesn't mean that the phone is invalid\n      // because phone number formats only format phone numbers,\n      // they don't validate them and some (rare) phone numbers\n      // are meant to stay non-formatted.\n\n      if (formatted_number) {\n        return formatted_number;\n      } // For some phone number formats national prefix\n      // If the previously chosen phone number format\n      // didn't match the next (current) digit being input\n      // (leading digits pattern didn't match).\n\n\n      if (this.chooseAnotherFormat()) {\n        // And a more appropriate phone number format\n        // has been chosen for these `leading digits`,\n        // then format the national phone number (so far)\n        // using the newly selected phone number pattern.\n        // Will return `undefined` if it couldn't format\n        // the supplied national number\n        // using the selected phone number pattern.\n        return this.reformatNationalNumber();\n      } // If could format the next (current) digit\n      // using the previously chosen phone number format\n      // then return the formatted number so far.\n      // If no new phone number format could be chosen,\n      // and couldn't format the supplied national number\n      // using the selected phone number pattern,\n      // then it will return `undefined`.\n\n\n      return national_number_formatted_with_previous_format;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      // Input stripped of non-phone-number characters.\n      // Can only contain a possible leading '+' sign and digits.\n      this.parsedInput = '';\n      this.currentOutput = ''; // This contains the national prefix that has been extracted. It contains only\n      // digits without formatting.\n\n      this.nationalPrefix = '';\n      this.nationalNumber = '';\n      this.carrierCode = '';\n      this.resetCountriness();\n      this.resetFormat();\n      return this;\n    }\n  }, {\n    key: 'resetCountry',\n    value: function resetCountry() {\n      if (this.isInternational()) {\n        this.country = undefined;\n      } else {\n        this.country = this.defaultCountry;\n      }\n    }\n  }, {\n    key: 'resetCountriness',\n    value: function resetCountriness() {\n      this.resetCountry();\n\n      if (this.defaultCountry && !this.isInternational()) {\n        this.metadata.country(this.defaultCountry);\n        this.countryCallingCode = this.metadata.countryCallingCode();\n        this.initialize_phone_number_formats_for_this_country_calling_code();\n      } else {\n        this.metadata.country(undefined);\n        this.countryCallingCode = undefined; // \"Available formats\" are all formats available for the country.\n        // \"Matching formats\" are only formats eligible for the national number being entered.\n\n        this.available_formats = [];\n        this.matching_formats = undefined;\n      }\n    }\n  }, {\n    key: 'resetFormat',\n    value: function resetFormat() {\n      this.chosenFormat = undefined;\n      this.template = undefined;\n      this.partially_populated_template = undefined;\n      this.last_match_position = -1;\n    } // Format each digit of national phone number (so far)\n    // using the newly selected phone number pattern.\n\n  }, {\n    key: 'reformatNationalNumber',\n    value: function reformatNationalNumber() {\n      // Format each digit of national phone number (so far)\n      // using the selected phone number pattern.\n      return this.formatNextNationalNumberDigits(this.nationalNumber);\n    }\n  }, {\n    key: 'initialize_phone_number_formats_for_this_country_calling_code',\n    value: function initialize_phone_number_formats_for_this_country_calling_code() {\n      // Get all \"eligible\" phone number formats for this country\n      this.available_formats = this.metadata.formats().filter(function (format) {\n        return ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat());\n      });\n      this.matching_formats = undefined;\n    }\n  }, {\n    key: 'match_formats_by_leading_digits',\n    value: function match_formats_by_leading_digits() {\n      var leading_digits = this.nationalNumber; // \"leading digits\" pattern list starts with a\n      // \"leading digits\" pattern fitting a maximum of 3 leading digits.\n      // So, after a user inputs 3 digits of a national (significant) phone number\n      // this national (significant) number can already be formatted.\n      // The next \"leading digits\" pattern is for 4 leading digits max,\n      // and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\n      // This implementation is different from Google's\n      // in that it searches for a fitting format\n      // even if the user has entered less than\n      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\n      // Because some leading digits patterns already match for a single first digit.\n\n      var index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH;\n\n      if (index_of_leading_digits_pattern < 0) {\n        index_of_leading_digits_pattern = 0;\n      } // \"Available formats\" are all formats available for the country.\n      // \"Matching formats\" are only formats eligible for the national number being entered.\n      // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available\n      // then format matching starts narrowing down the list of possible formats\n      // (only previously matched formats are considered for next digits).\n\n\n      var available_formats = this.had_enough_leading_digits && this.matching_formats || this.available_formats;\n      this.had_enough_leading_digits = this.shouldFormat();\n      this.matching_formats = available_formats.filter(function (format) {\n        var leading_digits_patterns_count = format.leadingDigitsPatterns().length; // If this format is not restricted to a certain\n        // leading digits pattern then it fits.\n\n        if (leading_digits_patterns_count === 0) {\n          return true;\n        }\n\n        var leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_patterns_count - 1);\n        var leading_digits_pattern = format.leadingDigitsPatterns()[leading_digits_pattern_index]; // Brackets are required for `^` to be applied to\n        // all or-ed (`|`) parts, not just the first one.\n\n        return new RegExp('^(' + leading_digits_pattern + ')').test(leading_digits);\n      }); // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n      // To construct a valid test case for this one can find a country\n      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\n      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).\n\n      if (this.chosenFormat && this.matching_formats.indexOf(this.chosenFormat) === -1) {\n        this.resetFormat();\n      }\n    }\n  }, {\n    key: 'shouldFormat',\n    value: function shouldFormat() {\n      // Start matching any formats at all when the national number\n      // entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives\n      // like when the digits entered so far are `2`\n      // and the leading digits pattern is `21` –\n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Presumably the limitation of \"3 digits min\"\n      // is imposed to exclude false matches,\n      // e.g. when there are two different formats\n      // each one fitting one or two leading digits being input.\n      // But for this case I would propose a specific `if/else` condition.\n      //\n      return this.nationalNumber.length >= MIN_LEADING_DIGITS_LENGTH;\n    } // Check to see if there is an exact pattern match for these digits. If so, we\n    // should use this instead of any other formatting template whose\n    // `leadingDigitsPattern` also matches the input.\n\n  }, {\n    key: 'attempt_to_format_complete_phone_number',\n    value: function attempt_to_format_complete_phone_number() {\n      for (var _iterator = this.matching_formats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var format = _ref;\n        var matcher = new RegExp('^(?:' + format.pattern() + ')$');\n\n        if (!matcher.test(this.nationalNumber)) {\n          continue;\n        }\n\n        if (!this.isFormatApplicable(format)) {\n          continue;\n        } // To leave the formatter in a consistent state\n\n\n        this.resetFormat();\n        this.chosenFormat = format;\n        var formatted_number = format_national_number_using_format(this.nationalNumber, format, this.isInternational(), this.nationalPrefix !== '', this.metadata); // Special handling for NANPA countries for AsYouType formatter.\n        // Copied from Google's `libphonenumber`:\n        // https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573\n\n        if (this.nationalPrefix && this.countryCallingCode === '1') {\n          formatted_number = '1 ' + formatted_number;\n        } // Set `this.template` and `this.partially_populated_template`.\n        //\n        // `else` case doesn't ever happen\n        // with the current metadata,\n        // but just in case.\n        //\n\n        /* istanbul ignore else */\n\n\n        if (this.createFormattingTemplate(format)) {\n          // Populate `this.partially_populated_template`\n          this.reformatNationalNumber();\n        } else {\n          // Prepend `+CountryCode` in case of an international phone number\n          var full_number = this.formatFullNumber(formatted_number);\n          this.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER);\n          this.partially_populated_template = full_number;\n        }\n\n        return formatted_number;\n      }\n    } // Prepends `+CountryCode` in case of an international phone number\n\n  }, {\n    key: 'formatFullNumber',\n    value: function formatFullNumber(formattedNationalNumber) {\n      if (this.isInternational()) {\n        return '+' + this.countryCallingCode + ' ' + formattedNationalNumber;\n      }\n\n      return formattedNationalNumber;\n    } // Extracts the country calling code from the beginning\n    // of the entered `national_number` (so far),\n    // and places the remaining input into the `national_number`.\n\n  }, {\n    key: 'extractCountryCallingCode',\n    value: function extractCountryCallingCode() {\n      var _extractCountryCallin = _extractCountryCallingCode(this.parsedInput, this.defaultCountry, this.metadata.metadata),\n          countryCallingCode = _extractCountryCallin.countryCallingCode,\n          number = _extractCountryCallin.number;\n\n      if (!countryCallingCode) {\n        return;\n      }\n\n      this.countryCallingCode = countryCallingCode; // Sometimes people erroneously write national prefix\n      // as part of an international number, e.g. +44 (0) ....\n      // This violates the standards for international phone numbers,\n      // so \"As You Type\" formatter assumes no national prefix\n      // when parsing a phone number starting from `+`.\n      // Even if it did attempt to filter-out that national prefix\n      // it would look weird for a user trying to enter a digit\n      // because from user's perspective the keyboard \"wouldn't be working\".\n\n      this.nationalNumber = number;\n      this.metadata.chooseCountryByCountryCallingCode(countryCallingCode);\n      return this.metadata.selectedCountry() !== undefined;\n    }\n  }, {\n    key: 'extractNationalPrefix',\n    value: function extractNationalPrefix() {\n      this.nationalPrefix = '';\n\n      if (!this.metadata.selectedCountry()) {\n        return;\n      } // Only strip national prefixes for non-international phone numbers\n      // because national prefixes can't be present in international phone numbers.\n      // While `parseNumber()` is forgiving is such cases, `AsYouType` is not.\n\n\n      var _strip_national_prefi = strip_national_prefix_and_carrier_code(this.nationalNumber, this.metadata),\n          potential_national_number = _strip_national_prefi.number,\n          carrierCode = _strip_national_prefi.carrierCode;\n\n      if (carrierCode) {\n        this.carrierCode = carrierCode;\n      } // We require that the NSN remaining after stripping the national prefix and\n      // carrier code be long enough to be a possible length for the region.\n      // Otherwise, we don't do the stripping, since the original number could be\n      // a valid short number.\n\n\n      if (!this.metadata.possibleLengths() || this.isPossibleNumber(this.nationalNumber) && !this.isPossibleNumber(potential_national_number)) {\n        // Verify the parsed national (significant) number for this country\n        //\n        // If the original number (before stripping national prefix) was viable,\n        // and the resultant number is not, then prefer the original phone number.\n        // This is because for some countries (e.g. Russia) the same digit could be both\n        // a national prefix and a leading digit of a valid national phone number,\n        // like `8` is the national prefix for Russia and both\n        // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n        if (matchesEntirely(this.nationalNumber, this.metadata.nationalNumberPattern()) && !matchesEntirely(potential_national_number, this.metadata.nationalNumberPattern())) {\n          return;\n        }\n      }\n\n      this.nationalPrefix = this.nationalNumber.slice(0, this.nationalNumber.length - potential_national_number.length);\n      this.nationalNumber = potential_national_number;\n      return this.nationalPrefix;\n    }\n  }, {\n    key: 'isPossibleNumber',\n    value: function isPossibleNumber(number) {\n      var validation_result = checkNumberLengthForType(number, undefined, this.metadata);\n\n      switch (validation_result) {\n        case 'IS_POSSIBLE':\n          return true;\n        // case 'IS_POSSIBLE_LOCAL_ONLY':\n        // \treturn !this.isInternational()\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'chooseAnotherFormat',\n    value: function chooseAnotherFormat() {\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      for (var _iterator2 = this.matching_formats, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var format = _ref2; // If this format is currently being used\n        // and is still possible, then stick to it.\n\n        if (this.chosenFormat === format) {\n          return;\n        } // If this `format` is suitable for \"as you type\",\n        // then extract the template from this format\n        // and use it to format the phone number being input.\n\n\n        if (!this.isFormatApplicable(format)) {\n          continue;\n        }\n\n        if (!this.createFormattingTemplate(format)) {\n          continue;\n        }\n\n        this.chosenFormat = format; // With a new formatting template, the matched position\n        // using the old template needs to be reset.\n\n        this.last_match_position = -1;\n        return true;\n      } // No format matches the phone number,\n      // therefore set `country` to `undefined`\n      // (or to the default country).\n\n\n      this.resetCountry(); // No format matches the national phone number entered\n\n      this.resetFormat();\n    }\n  }, {\n    key: 'isFormatApplicable',\n    value: function isFormatApplicable(format) {\n      // If national prefix is mandatory for this phone number format\n      // and the user didn't input the national prefix\n      // then this phone number format isn't suitable.\n      if (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormatting()) {\n        return false;\n      } // If this format doesn't use national prefix\n      // but the user did input national prefix\n      // then this phone number format isn't suitable.\n\n\n      if (this.nationalPrefix && !format.usesNationalPrefix() && !format.nationalPrefixIsOptionalWhenFormatting()) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'createFormattingTemplate',\n    value: function createFormattingTemplate(format) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n\n      /* istanbul ignore if */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\n        return;\n      } // Get formatting template for this phone number format\n\n\n      var template = this.getTemplateForNumberFormatPattern(format); // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (!template) {\n        return;\n      } // This one is for national number only\n\n\n      this.partially_populated_template = template; // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n\n      if (this.isInternational()) {\n        this.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) + ' ' + template;\n      } // For local numbers, replace national prefix\n      // with a digit placeholder.\n      else {\n          this.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER);\n        } // This one is for the full phone number\n\n\n      return this.template;\n    } // Generates formatting template for a phone number format\n\n  }, {\n    key: 'getTemplateForNumberFormatPattern',\n    value: function getTemplateForNumberFormatPattern(format) {\n      // A very smart trick by the guys at Google\n      var number_pattern = format.pattern();\n      /* istanbul ignore else */\n\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\n        number_pattern = number_pattern // Replace anything in the form of [..] with \\d\n        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d') // Replace any standalone digit (not the one in `{}`) with \\d\n        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d');\n      } // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n\n\n      var dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0]; // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (this.nationalNumber.length > dummy_phone_number_matching_format_pattern.length) {\n        return;\n      } // Prepare the phone number format\n\n\n      var number_format = this.getFormatFormat(format); // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n      // Below `strict_pattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strict_pattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.nationalNumber : `111111111` (9 digits)\n      //\n      // number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // number_format : `$1 $2 $3`\n      // dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `number_pattern`.\n      //\n      // The fix is, if `this.nationalNumber` has already sufficient length\n      // to satisfy the `number_pattern` completely then `this.nationalNumber` is used\n      // instead of `dummy_phone_number_matching_format_pattern`.\n\n      var strict_pattern = new RegExp('^' + number_pattern + '$');\n      var national_number_dummy_digits = this.nationalNumber.replace(/\\d/g, DUMMY_DIGIT); // If `this.nationalNumber` has already sufficient length\n      // to satisfy the `number_pattern` completely then use it\n      // instead of `dummy_phone_number_matching_format_pattern`.\n\n      if (strict_pattern.test(national_number_dummy_digits)) {\n        dummy_phone_number_matching_format_pattern = national_number_dummy_digits;\n      } // Generate formatting template for this phone number format\n\n\n      return dummy_phone_number_matching_format_pattern // Format the dummy phone number according to the format\n      .replace(new RegExp(number_pattern), number_format) // Replace each dummy digit with a DIGIT_PLACEHOLDER\n      .replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER);\n    }\n  }, {\n    key: 'formatNextNationalNumberDigits',\n    value: function formatNextNationalNumberDigits(digits) {\n      // Using `.split('')` to iterate through a string here\n      // to avoid requiring `Symbol.iterator` polyfill.\n      // `.split('')` is generally not safe for Unicode,\n      // but in this particular case for `digits` it is safe.\n      // for (const digit of digits)\n      for (var _iterator3 = digits.split(''), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var digit = _ref3; // If there is room for more digits in current `template`,\n        // then set the next digit in the `template`,\n        // and return the formatted digits so far.\n        // If more digits are entered than the current format could handle\n\n        if (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1) {\n          // Reset the current format,\n          // so that the new format will be chosen\n          // in a subsequent `this.chooseAnotherFormat()` call\n          // later in code.\n          this.chosenFormat = undefined;\n          this.template = undefined;\n          this.partially_populated_template = undefined;\n          return;\n        }\n\n        this.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER);\n        this.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n      } // Return the formatted phone number so far.\n\n\n      return cut_stripping_dangling_braces(this.partially_populated_template, this.last_match_position + 1); // The old way which was good for `input-format` but is not so good\n      // for `react-phone-number-input`'s default input (`InputBasic`).\n      // return close_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\n      // \t.replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ')\n    }\n  }, {\n    key: 'isInternational',\n    value: function isInternational() {\n      return this.parsedInput && this.parsedInput[0] === '+';\n    }\n  }, {\n    key: 'getFormatFormat',\n    value: function getFormatFormat(format) {\n      if (this.isInternational()) {\n        return changeInternationalFormatStyle(format.internationalFormat());\n      } // If national prefix formatting rule is set\n      // for this phone number format\n\n\n      if (format.nationalPrefixFormattingRule()) {\n        // If the user did input the national prefix\n        // (or if the national prefix formatting rule does not require national prefix)\n        // then maybe make it part of the phone number template\n        if (this.nationalPrefix || !format.usesNationalPrefix()) {\n          // Make the national prefix part of the phone number template\n          return format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());\n        }\n      } // Special handling for NANPA countries for AsYouType formatter.\n      // Copied from Google's `libphonenumber`:\n      // https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573\n      else if (this.countryCallingCode === '1' && this.nationalPrefix === '1') {\n          return '1 ' + format.format();\n        }\n\n      return format.format();\n    } // Determines the country of the phone number\n    // entered so far based on the country phone code\n    // and the national phone number.\n\n  }, {\n    key: 'determineTheCountry',\n    value: function determineTheCountry() {\n      this.country = find_country_code(this.countryCallingCode, this.nationalNumber, this.metadata);\n    }\n    /**\r\n     * Returns an instance of `PhoneNumber` class.\r\n     * Will return `undefined` if no national (significant) number\r\n     * digits have been entered so far, or if no `defaultCountry` has been\r\n     * set and the user enters a phone number not in international format.\r\n     */\n\n  }, {\n    key: 'getNumber',\n    value: function getNumber() {\n      if (!this.countryCallingCode || !this.nationalNumber) {\n        return undefined;\n      }\n\n      var phoneNumber = new PhoneNumber(this.country || this.countryCallingCode, this.nationalNumber, this.metadata.metadata);\n\n      if (this.carrierCode) {\n        phoneNumber.carrierCode = this.carrierCode;\n      } // Phone number extensions are not supported by \"As You Type\" formatter.\n\n\n      return phoneNumber;\n    } // This method is still used in `react-phone-number-input/source/input-control.js`.\n\n  }, {\n    key: 'getNationalNumber',\n    value: function getNationalNumber() {\n      return this.nationalNumber;\n    }\n  }, {\n    key: 'getTemplate',\n    value: function getTemplate() {\n      if (!this.template) {\n        return;\n      }\n\n      var index = -1;\n      var i = 0;\n\n      while (i < this.parsedInput.length) {\n        index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1);\n        i++;\n      }\n\n      return cut_stripping_dangling_braces(this.template, index + 1);\n    }\n  }]);\n\n  return AsYouType;\n}();\n\nexport default AsYouType;\nexport function strip_dangling_braces(string) {\n  var dangling_braces = [];\n  var i = 0;\n\n  while (i < string.length) {\n    if (string[i] === '(') {\n      dangling_braces.push(i);\n    } else if (string[i] === ')') {\n      dangling_braces.pop();\n    }\n\n    i++;\n  }\n\n  var start = 0;\n  var cleared_string = '';\n  dangling_braces.push(string.length);\n\n  for (var _iterator4 = dangling_braces, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n    var _ref4;\n\n    if (_isArray4) {\n      if (_i4 >= _iterator4.length) break;\n      _ref4 = _iterator4[_i4++];\n    } else {\n      _i4 = _iterator4.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var index = _ref4;\n    cleared_string += string.slice(start, index);\n    start = index + 1;\n  }\n\n  return cleared_string;\n}\nexport function cut_stripping_dangling_braces(string, cut_before_index) {\n  if (string[cut_before_index] === ')') {\n    cut_before_index++;\n  }\n\n  return strip_dangling_braces(string.slice(0, cut_before_index));\n}\nexport function close_dangling_braces(template, cut_before) {\n  var retained_template = template.slice(0, cut_before);\n  var opening_braces = count_occurences('(', retained_template);\n  var closing_braces = count_occurences(')', retained_template);\n  var dangling_braces = opening_braces - closing_braces;\n\n  while (dangling_braces > 0 && cut_before < template.length) {\n    if (template[cut_before] === ')') {\n      dangling_braces--;\n    }\n\n    cut_before++;\n  }\n\n  return template.slice(0, cut_before);\n} // Counts all occurences of a symbol in a string.\n// Unicode-unsafe (because using `.split()`).\n\nexport function count_occurences(symbol, string) {\n  var count = 0; // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for counting brackets it is safe.\n  // for (const character of string)\n\n  for (var _iterator5 = string.split(''), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n    var _ref5;\n\n    if (_isArray5) {\n      if (_i5 >= _iterator5.length) break;\n      _ref5 = _iterator5[_i5++];\n    } else {\n      _i5 = _iterator5.next();\n      if (_i5.done) break;\n      _ref5 = _i5.value;\n    }\n\n    var character = _ref5;\n\n    if (character === symbol) {\n      count++;\n    }\n  }\n\n  return count;\n} // Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\n\nexport function repeat(string, times) {\n  if (times < 1) {\n    return '';\n  }\n\n  var result = '';\n\n  while (times > 1) {\n    if (times & 1) {\n      result += string;\n    }\n\n    times >>= 1;\n    string += string;\n  }\n\n  return result + string;\n}","map":{"version":3,"sources":["../source/AsYouType.js"],"names":["extractCountryCallingCode","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","SUPPORT_LEGACY_FORMATTING_PATTERNS","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_INCOMPLETE_PHONE_NUMBER","VALID_INCOMPLETE_PHONE_NUMBER_PATTERN","AsYouType","options","defaultCountry","text","extracted_number","extract_formatted_phone_number","parseIncompletePhoneNumber","input","previous_national_prefix","formatted_national_phone_number","next_digits","national_number_formatted_with_previous_format","formatted_number","format","leading_digits","index_of_leading_digits_pattern","available_formats","leading_digits_patterns_count","leading_digits_pattern_index","Math","leading_digits_pattern","matcher","format_national_number_using_format","full_number","formattedNationalNumber","countryCallingCode","number","potential_national_number","carrierCode","strip_national_prefix_and_carrier_code","matchesEntirely","validation_result","checkNumberLengthForType","template","number_pattern","dummy_phone_number_matching_format_pattern","number_format","strict_pattern","national_number_dummy_digits","digits","digit","cut_stripping_dangling_braces","changeInternationalFormatStyle","find_country_code","phoneNumber","index","i","dangling_braces","string","start","cleared_string","cut_before_index","strip_dangling_braces","retained_template","opening_braces","count_occurences","closing_braces","cut_before","count","character","times","result"],"mappings":"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","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\r\n// `asyoutypeformatter.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\r\n//\r\n// Simplified: does not differentiate between \"local-only\" numbers\r\n// and \"internationally dialable\" numbers.\r\n// For example, doesn't include changes like this:\r\n// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\n\r\nimport {\r\n\textractCountryCallingCode,\r\n\textract_formatted_phone_number,\r\n\tfind_country_code,\r\n\tstrip_national_prefix_and_carrier_code\r\n} from './parse_'\r\n\r\nimport {\r\n\tFIRST_GROUP_PATTERN,\r\n\tformat_national_number_using_format,\r\n\tchangeInternationalFormatStyle\r\n} from './format_'\r\n\r\nimport { checkNumberLengthForType } from './getNumberType_'\r\n\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// The digits that have not been entered yet will be represented by a \\u2008,\r\n// the punctuation space.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A pattern that is used to determine if a `format` is eligible\r\n// to be used by the \"as you type formatter\".\r\n// It is eligible when the `format` contains groups of the dollar sign\r\n// followed by a single digit, separated by valid phone number punctuation.\r\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\r\n// getting into the output of the \"as you type formatter\".\r\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp\r\n(\r\n\t'^' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nconst VALID_INCOMPLETE_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i')\r\n\r\nexport default class AsYouType\r\n{\r\n\t// Not setting `options` to a constructor argument\r\n\t// not to break backwards compatibility\r\n\t// for older versions of the library.\r\n\toptions = {}\r\n\r\n\t/**\r\n\t * @param {string?} [defaultCountry] - The default country used for parsing non-international phone numbers.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(defaultCountry, metadata)\r\n\t{\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\r\n\t\tif (defaultCountry && this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tthis.defaultCountry = defaultCountry\r\n\t\t}\r\n\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tinput(text)\r\n\t{\r\n\t\t// Parse input\r\n\r\n\t\tlet extracted_number = extract_formatted_phone_number(text) || ''\r\n\r\n\t\t// Special case for a lone '+' sign\r\n\t\t// since it's not considered a possible phone number.\r\n\t\tif (!extracted_number)\r\n\t\t{\r\n\t\t\tif (text && text.indexOf('+') >= 0)\r\n\t\t\t{\r\n\t\t\t\textracted_number = '+'\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Validate possible first part of a phone number\r\n\t\tif (!VALID_INCOMPLETE_PHONE_NUMBER_PATTERN.test(extracted_number))\r\n\t\t{\r\n\t\t\treturn this.currentOutput\r\n\t\t}\r\n\r\n\t\treturn this.processInput(parseIncompletePhoneNumber(extracted_number))\r\n\t}\r\n\r\n\tprocessInput(input)\r\n\t{\r\n\t\t// If an out of position '+' sign detected\r\n\t\t// (or a second '+' sign),\r\n\t\t// then just drop it from the input.\r\n\t\tif (input[0] === '+')\r\n\t\t{\r\n\t\t\tif (!this.parsedInput)\r\n\t\t\t{\r\n\t\t\t\tthis.parsedInput += '+'\r\n\r\n\t\t\t\t// If a default country was set\r\n\t\t\t\t// then reset it because an explicitly international\r\n\t\t\t\t// phone number is being entered\r\n\t\t\t\tthis.resetCountriness()\r\n\t\t\t}\r\n\r\n\t\t\tinput = input.slice(1)\r\n\t\t}\r\n\r\n\t\t// Raw phone number\r\n\t\tthis.parsedInput += input\r\n\r\n\t\t// // Reset phone number validation state\r\n\t\t// this.valid = false\r\n\r\n\t\t// Add digits to the national number\r\n\t\tthis.nationalNumber += input\r\n\r\n\t\t// TODO: Deprecated: rename `this.nationalNumber`\r\n\t\t// to `this.nationalNumber` and remove `.getNationalNumber()`.\r\n\r\n\t\t// Try to format the parsed input\r\n\r\n\t\tif (this.isInternational())\r\n\t\t{\r\n\t\t\tif (!this.countryCallingCode)\r\n\t\t\t{\r\n\t\t\t\t// Extract country calling code from the digits entered so far.\r\n\r\n\t\t\t\t// There must be some digits in order to extract anything from them.\r\n\t\t\t\tif (!this.nationalNumber)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Return raw phone number\r\n\t\t\t\t\treturn this.parsedInput\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If one looks at country phone codes\r\n\t\t\t\t// then he can notice that no one country phone code\r\n\t\t\t\t// is ever a (leftmost) substring of another country phone code.\r\n\t\t\t\t// So if a valid country code is extracted so far\r\n\t\t\t\t// then it means that this is the country code.\r\n\r\n\t\t\t\t// If no country phone code could be extracted so far,\r\n\t\t\t\t// then just return the raw phone number,\r\n\t\t\t\t// because it has no way of knowing\r\n\t\t\t\t// how to format the phone number so far.\r\n\t\t\t\tif (!this.extractCountryCallingCode())\r\n\t\t\t\t{\r\n\t\t\t\t\t// Return raw phone number\r\n\t\t\t\t\treturn this.parsedInput\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Initialize country-specific data\r\n\t\t\t\tthis.initialize_phone_number_formats_for_this_country_calling_code()\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t\t// `this.country` could be `undefined`,\r\n\t\t\t// for instance, when there is ambiguity\r\n\t\t\t// in a form of several different countries\r\n\t\t\t// each corresponding to the same country phone code\r\n\t\t\t// (e.g. NANPA: USA, Canada, etc),\r\n\t\t\t// and there's not enough digits entered\r\n\t\t\t// to reliably determine the country\r\n\t\t\t// the phone number belongs to.\r\n\t\t\t// Therefore, in cases of such ambiguity,\r\n\t\t\t// each time something is input,\r\n\t\t\t// try to determine the country\r\n\t\t\t// (if it's not determined yet).\r\n\t\t\telse if (!this.country)\r\n\t\t\t{\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Some national prefixes are substrings of other national prefixes\r\n\t\t\t// (for the same country), therefore try to extract national prefix each time\r\n\t\t\t// because a longer national prefix might be available at some point in time.\r\n\r\n\t\t\tconst previous_national_prefix = this.nationalPrefix\r\n\t\t\tthis.nationalNumber = this.nationalPrefix + this.nationalNumber\r\n\r\n\t\t\t// Possibly extract a national prefix\r\n\t\t\tthis.extractNationalPrefix()\r\n\r\n\t\t\tif (this.nationalPrefix !== previous_national_prefix)\r\n\t\t\t{\r\n\t\t\t\t// National number has changed\r\n\t\t\t\t// (due to another national prefix been extracted)\r\n\t\t\t\t// therefore national number has changed\r\n\t\t\t\t// therefore reset all previous formatting data.\r\n\t\t\t\t// (and leading digits matching state)\r\n\t\t\t\tthis.matching_formats = undefined\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if (!this.shouldFormat())\r\n\t\t// {\r\n\t\t// \treturn this.format_as_non_formatted_number()\r\n\t\t// }\r\n\r\n\t\tif (!this.nationalNumber)\r\n\t\t{\r\n\t\t\treturn this.format_as_non_formatted_number()\r\n\t\t}\r\n\r\n\t\t// Check the available phone number formats\r\n\t\t// based on the currently available leading digits.\r\n\t\tthis.match_formats_by_leading_digits()\r\n\r\n\t\t// Format the phone number (given the next digits)\r\n\t\tconst formatted_national_phone_number = this.formatNationalNumber(input)\r\n\r\n\t\t// If the phone number could be formatted,\r\n\t\t// then return it, possibly prepending with country phone code\r\n\t\t// (for international phone numbers only)\r\n\t\tif (formatted_national_phone_number)\r\n\t\t{\r\n\t\t\treturn this.formatFullNumber(formatted_national_phone_number)\r\n\t\t}\r\n\r\n\t\t// If the phone number couldn't be formatted,\r\n\t\t// then just fall back to the raw phone number.\r\n\t\treturn this.format_as_non_formatted_number()\r\n\t}\r\n\r\n\tformat_as_non_formatted_number()\r\n\t{\r\n\t\t// Strip national prefix for incorrectly inputted international phones.\r\n\t\tif (this.isInternational() && this.countryCallingCode)\r\n\t\t{\r\n\t\t\treturn `+${this.countryCallingCode}${this.nationalNumber}`\r\n\t\t}\r\n\r\n\t\treturn this.parsedInput\r\n\t}\r\n\r\n\tformatNationalNumber(next_digits)\r\n\t{\r\n\t\t// Format the next phone number digits\r\n\t\t// using the previously chosen phone number format.\r\n\t\t//\r\n\t\t// This is done here because if `attempt_to_format_complete_phone_number`\r\n\t\t// was placed before this call then the `template`\r\n\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\r\n\t\t//\r\n\t\tlet national_number_formatted_with_previous_format\r\n\t\tif (this.chosenFormat)\r\n\t\t{\r\n\t\t\tnational_number_formatted_with_previous_format = this.formatNextNationalNumberDigits(next_digits)\r\n\t\t}\r\n\r\n\t\t// See if the input digits can be formatted properly already. If not,\r\n\t\t// use the results from formatNextNationalNumberDigits(), which does formatting\r\n\t\t// based on the formatting pattern chosen.\r\n\r\n\t\tconst formatted_number = this.attempt_to_format_complete_phone_number()\r\n\r\n\t\t// Just because a phone number doesn't have a suitable format\r\n\t\t// that doesn't mean that the phone is invalid\r\n\t\t// because phone number formats only format phone numbers,\r\n\t\t// they don't validate them and some (rare) phone numbers\r\n\t\t// are meant to stay non-formatted.\r\n\t\tif (formatted_number)\r\n\t\t{\r\n\t\t\treturn formatted_number\r\n\t\t}\r\n\r\n\t\t// For some phone number formats national prefix\r\n\r\n\t\t// If the previously chosen phone number format\r\n\t\t// didn't match the next (current) digit being input\r\n\t\t// (leading digits pattern didn't match).\r\n\t\tif (this.chooseAnotherFormat())\r\n\t\t{\r\n\t\t\t// And a more appropriate phone number format\r\n\t\t\t// has been chosen for these `leading digits`,\r\n\t\t\t// then format the national phone number (so far)\r\n\t\t\t// using the newly selected phone number pattern.\r\n\r\n\t\t\t// Will return `undefined` if it couldn't format\r\n\t\t\t// the supplied national number\r\n\t\t\t// using the selected phone number pattern.\r\n\r\n\t\t\treturn this.reformatNationalNumber()\r\n\t\t}\r\n\r\n\t\t// If could format the next (current) digit\r\n\t\t// using the previously chosen phone number format\r\n\t\t// then return the formatted number so far.\r\n\r\n\t\t// If no new phone number format could be chosen,\r\n\t\t// and couldn't format the supplied national number\r\n\t\t// using the selected phone number pattern,\r\n\t\t// then it will return `undefined`.\r\n\r\n\t\treturn national_number_formatted_with_previous_format\r\n\t}\r\n\r\n\treset()\r\n\t{\r\n\t\t// Input stripped of non-phone-number characters.\r\n\t\t// Can only contain a possible leading '+' sign and digits.\r\n\t\tthis.parsedInput = ''\r\n\r\n\t\tthis.currentOutput = ''\r\n\r\n\t\t// This contains the national prefix that has been extracted. It contains only\r\n\t\t// digits without formatting.\r\n\t\tthis.nationalPrefix = ''\r\n\r\n\t\tthis.nationalNumber = ''\r\n\t\tthis.carrierCode = ''\r\n\r\n\t\tthis.resetCountriness()\r\n\r\n\t\tthis.resetFormat()\r\n\r\n\t\treturn this\r\n\t}\r\n\r\n\tresetCountry()\r\n\t{\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.country = undefined\r\n\t\t} else {\r\n\t\t\tthis.country = this.defaultCountry\r\n\t\t}\r\n\t}\r\n\r\n\tresetCountriness()\r\n\t{\r\n\t\tthis.resetCountry()\r\n\r\n\t\tif (this.defaultCountry && !this.isInternational())\r\n\t\t{\r\n\t\t\tthis.metadata.country(this.defaultCountry)\r\n\t\t\tthis.countryCallingCode = this.metadata.countryCallingCode()\r\n\r\n\t\t\tthis.initialize_phone_number_formats_for_this_country_calling_code()\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.metadata.country(undefined)\r\n\t\t\tthis.countryCallingCode = undefined\r\n\r\n\t\t\t// \"Available formats\" are all formats available for the country.\r\n\t\t\t// \"Matching formats\" are only formats eligible for the national number being entered.\r\n\t\t\tthis.available_formats = []\r\n\t\t\tthis.matching_formats = undefined\r\n\t\t}\r\n\t}\r\n\r\n\tresetFormat()\r\n\t{\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.partially_populated_template = undefined\r\n\t\tthis.last_match_position = -1\r\n\t}\r\n\r\n\t// Format each digit of national phone number (so far)\r\n\t// using the newly selected phone number pattern.\r\n\treformatNationalNumber()\r\n\t{\r\n\t\t// Format each digit of national phone number (so far)\r\n\t\t// using the selected phone number pattern.\r\n\t\treturn this.formatNextNationalNumberDigits(this.nationalNumber)\r\n\t}\r\n\r\n\tinitialize_phone_number_formats_for_this_country_calling_code()\r\n\t{\r\n\t\t// Get all \"eligible\" phone number formats for this country\r\n\t\tthis.available_formats = this.metadata.formats().filter((format) =>\r\n\t\t{\r\n\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat())\r\n\t\t})\r\n\r\n\t\tthis.matching_formats = undefined\r\n\t}\r\n\r\n\tmatch_formats_by_leading_digits()\r\n\t{\r\n\t\tconst leading_digits = this.nationalNumber\r\n\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digits patterns already match for a single first digit.\r\n\t\tlet index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (index_of_leading_digits_pattern < 0) {\r\n\t\t\tindex_of_leading_digits_pattern = 0\r\n\t\t}\r\n\r\n\t\t// \"Available formats\" are all formats available for the country.\r\n\t\t// \"Matching formats\" are only formats eligible for the national number being entered.\r\n\r\n\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available\r\n\t\t// then format matching starts narrowing down the list of possible formats\r\n\t\t// (only previously matched formats are considered for next digits).\r\n\t\tconst available_formats = this.had_enough_leading_digits && this.matching_formats || this.available_formats\r\n\t\tthis.had_enough_leading_digits = this.shouldFormat()\r\n\r\n\t\tthis.matching_formats = available_formats.filter((format) =>\r\n\t\t{\r\n\t\t\tconst leading_digits_patterns_count = format.leadingDigitsPatterns().length\r\n\r\n\t\t\t// If this format is not restricted to a certain\r\n\t\t\t// leading digits pattern then it fits.\r\n\t\t\tif (leading_digits_patterns_count === 0)\r\n\t\t\t{\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\r\n\t\t\tconst leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_patterns_count - 1)\r\n\t\t\tconst leading_digits_pattern = format.leadingDigitsPatterns()[leading_digits_pattern_index]\r\n\r\n\t\t\t// Brackets are required for `^` to be applied to\r\n\t\t\t// all or-ed (`|`) parts, not just the first one.\r\n\t\t\treturn new RegExp(`^(${leading_digits_pattern})`).test(leading_digits)\r\n\t\t})\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matching_formats.indexOf(this.chosenFormat) === -1)\r\n\t\t{\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tshouldFormat()\r\n\t{\r\n\t\t// Start matching any formats at all when the national number\r\n\t\t// entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives\r\n\t\t// like when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` –\r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Presumably the limitation of \"3 digits min\"\r\n\t\t// is imposed to exclude false matches,\r\n\t\t// e.g. when there are two different formats\r\n\t\t// each one fitting one or two leading digits being input.\r\n\t\t// But for this case I would propose a specific `if/else` condition.\r\n\t\t//\r\n\t\treturn this.nationalNumber.length >= MIN_LEADING_DIGITS_LENGTH\r\n\t}\r\n\r\n\t// Check to see if there is an exact pattern match for these digits. If so, we\r\n\t// should use this instead of any other formatting template whose\r\n\t// `leadingDigitsPattern` also matches the input.\r\n\tattempt_to_format_complete_phone_number()\r\n\t{\r\n\t\tfor (const format of this.matching_formats)\r\n\t\t{\r\n\t\t\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\r\n\t\t\tif (!matcher.test(this.nationalNumber))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.isFormatApplicable(format))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\t// To leave the formatter in a consistent state\r\n\t\t\tthis.resetFormat()\r\n\t\t\tthis.chosenFormat = format\r\n\r\n\t\t\tlet formatted_number = format_national_number_using_format\r\n\t\t\t(\r\n\t\t\t\tthis.nationalNumber,\r\n\t\t\t\tformat,\r\n\t\t\t\tthis.isInternational(),\r\n\t\t\t\tthis.nationalPrefix !== '',\r\n\t\t\t\tthis.metadata\r\n\t\t\t)\r\n\r\n\t\t\t// Special handling for NANPA countries for AsYouType formatter.\r\n\t\t\t// Copied from Google's `libphonenumber`:\r\n\t\t\t// https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573\r\n\t\t\tif (this.nationalPrefix && this.countryCallingCode === '1') {\r\n\t\t\t\tformatted_number = '1 ' + formatted_number\r\n\t\t\t}\r\n\r\n\t\t\t// Set `this.template` and `this.partially_populated_template`.\r\n\t\t\t//\r\n\t\t\t// `else` case doesn't ever happen\r\n\t\t\t// with the current metadata,\r\n\t\t\t// but just in case.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this.createFormattingTemplate(format))\r\n\t\t\t{\r\n\t\t\t\t// Populate `this.partially_populated_template`\r\n\t\t\t\tthis.reformatNationalNumber()\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Prepend `+CountryCode` in case of an international phone number\r\n\t\t\t\tconst full_number = this.formatFullNumber(formatted_number)\r\n\t\t\t\tthis.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\r\n\t\t\t\tthis.partially_populated_template = full_number\r\n\t\t\t}\r\n\r\n\t\t\treturn formatted_number\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode` in case of an international phone number\r\n\tformatFullNumber(formattedNationalNumber)\r\n\t{\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn `+${this.countryCallingCode} ${formattedNationalNumber}`\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\t// Extracts the country calling code from the beginning\r\n\t// of the entered `national_number` (so far),\r\n\t// and places the remaining input into the `national_number`.\r\n\textractCountryCallingCode()\r\n\t{\r\n\t\tconst { countryCallingCode, number } = extractCountryCallingCode(this.parsedInput, this.defaultCountry, this.metadata.metadata)\r\n\r\n\t\tif (!countryCallingCode)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\r\n\t\t// Sometimes people erroneously write national prefix\r\n\t\t// as part of an international number, e.g. +44 (0) ....\r\n\t\t// This violates the standards for international phone numbers,\r\n\t\t// so \"As You Type\" formatter assumes no national prefix\r\n\t\t// when parsing a phone number starting from `+`.\r\n\t\t// Even if it did attempt to filter-out that national prefix\r\n\t\t// it would look weird for a user trying to enter a digit\r\n\t\t// because from user's perspective the keyboard \"wouldn't be working\".\r\n\t\tthis.nationalNumber = number\r\n\r\n\t\tthis.metadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t\treturn this.metadata.selectedCountry() !== undefined\r\n\t}\r\n\r\n\textractNationalPrefix()\r\n\t{\r\n\t\tthis.nationalPrefix = ''\r\n\r\n\t\tif (!this.metadata.selectedCountry()) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Only strip national prefixes for non-international phone numbers\r\n\t\t// because national prefixes can't be present in international phone numbers.\r\n\t\t// While `parseNumber()` is forgiving is such cases, `AsYouType` is not.\r\n\t\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(this.nationalNumber, this.metadata)\r\n\r\n\t\tif (carrierCode) {\r\n\t\t\tthis.carrierCode = carrierCode\r\n\t\t}\r\n\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tif (!this.metadata.possibleLengths() ||\r\n\t\t\tthis.isPossibleNumber(this.nationalNumber) &&\r\n\t\t\t!this.isPossibleNumber(potential_national_number))\r\n\t\t{\r\n\t\t\t// Verify the parsed national (significant) number for this country\r\n\t\t\t//\r\n\t\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t\t// like `8` is the national prefix for Russia and both\r\n\t\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\t\tif (matchesEntirely(this.nationalNumber, this.metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matchesEntirely(potential_national_number, this.metadata.nationalNumberPattern()))\r\n\t\t\t{\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.nationalPrefix = this.nationalNumber.slice(0, this.nationalNumber.length - potential_national_number.length)\r\n\t\tthis.nationalNumber = potential_national_number\r\n\r\n\t\treturn this.nationalPrefix\r\n\t}\r\n\r\n\tisPossibleNumber(number)\r\n\t{\r\n\t\tconst validation_result = checkNumberLengthForType(number, undefined, this.metadata)\r\n\t\tswitch (validation_result)\r\n\t\t{\r\n\t\t\tcase 'IS_POSSIBLE':\r\n\t\t\t\treturn true\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\t// \treturn !this.isInternational()\r\n\t\t\tdefault:\r\n\t\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\tchooseAnotherFormat()\r\n\t{\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\tfor (const format of this.matching_formats)\r\n\t\t{\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still possible, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\t// If this `format` is suitable for \"as you type\",\r\n\t\t\t// then extract the template from this format\r\n\t\t\t// and use it to format the phone number being input.\r\n\r\n\t\t\tif (!this.isFormatApplicable(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.createFormattingTemplate(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tthis.chosenFormat = format\r\n\r\n\t\t\t// With a new formatting template, the matched position\r\n\t\t\t// using the old template needs to be reset.\r\n\t\t\tthis.last_match_position = -1\r\n\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// No format matches the phone number,\r\n\t\t// therefore set `country` to `undefined`\r\n\t\t// (or to the default country).\r\n\t\tthis.resetCountry()\r\n\r\n\t\t// No format matches the national phone number entered\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\tisFormatApplicable(format)\r\n\t{\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and the user didn't input the national prefix\r\n\t\t// then this phone number format isn't suitable.\r\n\t\tif (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormatting()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// If this format doesn't use national prefix\r\n\t\t// but the user did input national prefix\r\n\t\t// then this phone number format isn't suitable.\r\n\t\tif (this.nationalPrefix && !format.usesNationalPrefix() && !format.nationalPrefixIsOptionalWhenFormatting()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\r\n\tcreateFormattingTemplate(format)\r\n\t{\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.getTemplateForNumberFormatPattern(format)\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (!template) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// This one is for national number only\r\n\t\tthis.partially_populated_template = template\r\n\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) + ' ' + template\r\n\t\t}\r\n\t\t// For local numbers, replace national prefix\r\n\t\t// with a digit placeholder.\r\n\t\telse {\r\n\t\t\tthis.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\r\n\t\t// This one is for the full phone number\r\n\t\treturn this.template\r\n\t}\r\n\r\n\t// Generates formatting template for a phone number format\r\n\tgetTemplateForNumberFormatPattern(format)\r\n\t{\r\n\t\t// A very smart trick by the guys at Google\r\n\t\tlet number_pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS)\r\n\t\t{\r\n\t\t\tnumber_pattern = number_pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\tlet dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (this.nationalNumber.length > dummy_phone_number_matching_format_pattern.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Prepare the phone number format\r\n\t\tconst number_format = this.getFormatFormat(format)\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strict_pattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strict_pattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalNumber : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// number_format : `$1 $2 $3`\r\n\t\t// dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `number_pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalNumber` has already sufficient length\r\n\t\t// to satisfy the `number_pattern` completely then `this.nationalNumber` is used\r\n\t\t// instead of `dummy_phone_number_matching_format_pattern`.\r\n\r\n\t\tconst strict_pattern = new RegExp('^' + number_pattern + '$')\r\n\t\tconst national_number_dummy_digits = this.nationalNumber.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalNumber` has already sufficient length\r\n\t\t// to satisfy the `number_pattern` completely then use it\r\n\t\t// instead of `dummy_phone_number_matching_format_pattern`.\r\n\t\tif (strict_pattern.test(national_number_dummy_digits)) {\r\n\t\t\tdummy_phone_number_matching_format_pattern = national_number_dummy_digits\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format\r\n\t\treturn dummy_phone_number_matching_format_pattern\r\n\t\t\t// Format the dummy phone number according to the format\r\n\t\t\t.replace(new RegExp(number_pattern), number_format)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits)\r\n\t{\r\n\t\t// Using `.split('')` to iterate through a string here\r\n\t\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t\t// `.split('')` is generally not safe for Unicode,\r\n\t\t// but in this particular case for `digits` it is safe.\r\n\t\t// for (const digit of digits)\r\n\t\tfor (const digit of digits.split(''))\r\n\t\t{\r\n\t\t\t// If there is room for more digits in current `template`,\r\n\t\t\t// then set the next digit in the `template`,\r\n\t\t\t// and return the formatted digits so far.\r\n\r\n\t\t\t// If more digits are entered than the current format could handle\r\n\t\t\tif (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1)\r\n\t\t\t{\r\n\t\t\t\t// Reset the current format,\r\n\t\t\t\t// so that the new format will be chosen\r\n\t\t\t\t// in a subsequent `this.chooseAnotherFormat()` call\r\n\t\t\t\t// later in code.\r\n\t\t\t\tthis.chosenFormat = undefined\r\n\t\t\t\tthis.template = undefined\r\n\t\t\t\tthis.partially_populated_template = undefined\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\t\tthis.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t\t}\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cut_stripping_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return close_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\r\n\t\t// \t.replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ')\r\n\t}\r\n\r\n\tisInternational() {\r\n\t\treturn this.parsedInput && this.parsedInput[0] === '+'\r\n\t}\r\n\r\n\tgetFormatFormat(format)\r\n\t{\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn changeInternationalFormatStyle(format.internationalFormat())\r\n\t\t}\r\n\r\n\t\t// If national prefix formatting rule is set\r\n\t\t// for this phone number format\r\n\t\tif (format.nationalPrefixFormattingRule())\r\n\t\t{\r\n\t\t\t// If the user did input the national prefix\r\n\t\t\t// (or if the national prefix formatting rule does not require national prefix)\r\n\t\t\t// then maybe make it part of the phone number template\r\n\t\t\tif (this.nationalPrefix || !format.usesNationalPrefix())\r\n\t\t\t{\r\n\t\t\t\t// Make the national prefix part of the phone number template\r\n\t\t\t\treturn format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Special handling for NANPA countries for AsYouType formatter.\r\n\t\t// Copied from Google's `libphonenumber`:\r\n\t\t// https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573\r\n\t\telse if (this.countryCallingCode === '1' && this.nationalPrefix === '1') {\r\n\t\t\treturn `1 ${format.format()}`\r\n\t\t}\r\n\r\n\t\treturn format.format()\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.country = find_country_code(this.countryCallingCode, this.nationalNumber, this.metadata)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber()\r\n\t{\r\n\t\tif (!this.countryCallingCode || !this.nationalNumber) {\r\n\t\t\treturn undefined\r\n\t\t}\r\n\t\tconst phoneNumber = new PhoneNumber(this.country || this.countryCallingCode, this.nationalNumber, this.metadata.metadata)\r\n\t\tif (this.carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = this.carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// This method is still used in `react-phone-number-input/source/input-control.js`.\r\n\tgetNationalNumber() {\r\n\t\treturn this.nationalNumber\r\n\t}\r\n\r\n\tgetTemplate()\r\n\t{\r\n\t\tif (!this.template) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet index = -1\r\n\r\n\t\tlet i = 0\r\n\t\twhile (i < this.parsedInput.length)\r\n\t\t{\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\r\n\t\treturn cut_stripping_dangling_braces(this.template, index + 1)\r\n\t}\r\n}\r\n\r\nexport function strip_dangling_braces(string)\r\n{\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length)\r\n\t{\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces)\r\n\t{\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\r\n\treturn cleared_string\r\n}\r\n\r\nexport function cut_stripping_dangling_braces(string, cut_before_index)\r\n{\r\n\tif (string[cut_before_index] === ')') {\r\n\t\tcut_before_index++\r\n\t}\r\n\treturn strip_dangling_braces(string.slice(0, cut_before_index))\r\n}\r\n\r\nexport function close_dangling_braces(template, cut_before)\r\n{\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\r\n\tconst opening_braces = count_occurences('(', retained_template)\r\n\tconst closing_braces = count_occurences(')', retained_template)\r\n\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length)\r\n\t{\r\n\t\tif (template[cut_before] === ')')\r\n\t\t{\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function count_occurences(symbol, string)\r\n{\r\n\tlet count = 0\r\n\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split(''))\r\n\t{\r\n\t\tif (character === symbol)\r\n\t\t{\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times)\r\n{\r\n\tif (times < 1)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\tlet result = ''\r\n\r\n\twhile (times > 1)\r\n\t{\r\n\t\tif (times & 1)\r\n\t\t{\r\n\t\t\tresult += string\r\n\t\t}\r\n\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\r\n\treturn result + string\r\n}"]},"metadata":{},"sourceType":"module"}