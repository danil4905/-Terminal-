{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (template) {\n  var placeholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n  var should_close_braces = arguments[2];\n\n  if (!template) {\n    return function (value) {\n      return {\n        text: value\n      };\n    };\n  }\n\n  var characters_in_template = (0, _helpers.count_occurences)(placeholder, template);\n  return function (value) {\n    if (!value) {\n      return {\n        text: '',\n        template: template\n      };\n    }\n\n    var value_character_index = 0;\n    var filled_in_template = ''; // Using `.split('')` here instead of normal `for ... of`\n    // because the importing application doesn't neccessarily include an ES6 polyfill.\n    // The `.split('')` approach discards \"exotic\" UTF-8 characters\n    // (the ones consisting of four bytes)\n    // but template placeholder characters don't fall into that range\n    // and appending UTF-8 characters to a string in parts still works.\n\n    for (var _iterator = template.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var character = _ref;\n\n      if (character !== placeholder) {\n        filled_in_template += character;\n        continue;\n      }\n\n      filled_in_template += value[value_character_index];\n      value_character_index++; // If the last available value character has been filled in,\n      // then return the filled in template\n      // (either trim the right part or retain it,\n      //  if no more character placeholders in there)\n\n      if (value_character_index === value.length) {\n        // If there are more character placeholders\n        // in the right part of the template\n        // then simply trim it.\n        if (value.length < characters_in_template) {\n          break;\n        }\n      }\n    }\n\n    if (should_close_braces) {\n      filled_in_template = (0, _closeBraces2.default)(filled_in_template, template);\n    }\n\n    return {\n      text: filled_in_template,\n      template: template\n    };\n  };\n};\n\nvar _helpers = require('./helpers');\n\nvar _closeBraces = require('./close braces');\n\nvar _closeBraces2 = _interopRequireDefault(_closeBraces);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} //# sourceMappingURL=template formatter.js.map","map":{"version":3,"sources":["/Users/danilkonovalov/my-app/node_modules/input-format/modules/template formatter.js"],"names":["Object","defineProperty","exports","value","default","template","placeholder","arguments","length","undefined","should_close_braces","text","characters_in_template","_helpers","count_occurences","value_character_index","filled_in_template","_iterator","split","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","character","_closeBraces2","require","_closeBraces","_interopRequireDefault","obj","__esModule"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nexports.default = function (template) {\n\tvar placeholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n\tvar should_close_braces = arguments[2];\n\n\tif (!template) {\n\t\treturn function (value) {\n\t\t\treturn { text: value };\n\t\t};\n\t}\n\n\tvar characters_in_template = (0, _helpers.count_occurences)(placeholder, template);\n\n\treturn function (value) {\n\t\tif (!value) {\n\t\t\treturn { text: '', template: template };\n\t\t}\n\n\t\tvar value_character_index = 0;\n\t\tvar filled_in_template = '';\n\n\t\t// Using `.split('')` here instead of normal `for ... of`\n\t\t// because the importing application doesn't neccessarily include an ES6 polyfill.\n\t\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\n\t\t// (the ones consisting of four bytes)\n\t\t// but template placeholder characters don't fall into that range\n\t\t// and appending UTF-8 characters to a string in parts still works.\n\t\tfor (var _iterator = template.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t\t\tvar _ref;\n\n\t\t\tif (_isArray) {\n\t\t\t\tif (_i >= _iterator.length) break;\n\t\t\t\t_ref = _iterator[_i++];\n\t\t\t} else {\n\t\t\t\t_i = _iterator.next();\n\t\t\t\tif (_i.done) break;\n\t\t\t\t_ref = _i.value;\n\t\t\t}\n\n\t\t\tvar character = _ref;\n\n\t\t\tif (character !== placeholder) {\n\t\t\t\tfilled_in_template += character;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilled_in_template += value[value_character_index];\n\t\t\tvalue_character_index++;\n\n\t\t\t// If the last available value character has been filled in,\n\t\t\t// then return the filled in template\n\t\t\t// (either trim the right part or retain it,\n\t\t\t//  if no more character placeholders in there)\n\t\t\tif (value_character_index === value.length) {\n\t\t\t\t// If there are more character placeholders\n\t\t\t\t// in the right part of the template\n\t\t\t\t// then simply trim it.\n\t\t\t\tif (value.length < characters_in_template) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (should_close_braces) {\n\t\t\tfilled_in_template = (0, _closeBraces2.default)(filled_in_template, template);\n\t\t}\n\n\t\treturn { text: filled_in_template, template: template };\n\t};\n};\n\nvar _helpers = require('./helpers');\n\nvar _closeBraces = require('./close braces');\n\nvar _closeBraces2 = _interopRequireDefault(_closeBraces);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n//# sourceMappingURL=template formatter.js.map"]},"metadata":{},"sourceType":"script"}