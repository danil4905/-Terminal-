{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPreSelectedCountry = getPreSelectedCountry;\nexports.getCountrySelectOptions = getCountrySelectOptions;\nexports.parsePhoneNumber = parsePhoneNumber;\nexports.generateNationalNumberDigits = generateNationalNumberDigits;\nexports.migrateParsedInputForNewCountry = migrateParsedInputForNewCountry;\nexports.e164 = e164;\nexports.trimNumber = trimNumber;\nexports.getCountryForPartialE164Number = getCountryForPartialE164Number;\nexports.parseInput = parseInput;\nexports.get_country_from_possibly_incomplete_international_phone_number = get_country_from_possibly_incomplete_international_phone_number;\nexports.compare_strings = compare_strings;\nexports.strip_country_calling_code = strip_country_calling_code;\nexports.get_national_significant_number_part = get_national_significant_number_part;\nexports.could_number_belong_to_country = could_number_belong_to_country;\n\nvar _core = require('libphonenumber-js/core');\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\n\n\nfunction getPreSelectedCountry(phoneNumber, country, countries, includeInternationalOption, metadata) {\n  // If can get country from E.164 phone number\n  // then it overrides the `country` passed (or not passed).\n  if (phoneNumber && phoneNumber.country) {\n    // `country` will be left `undefined` in case of non-detection.\n    country = phoneNumber.country;\n  } // Only pre-select a country if it's in the available `countries` list.\n\n\n  if (countries && countries.indexOf(country) < 0) {\n    country = undefined;\n  } // If there will be no \"International\" option\n  // then some `country` must be selected.\n  // It will still be the wrong country though.\n  // But still country `<select/>` can't be left in a broken state.\n\n\n  if (!country && !includeInternationalOption && countries && countries.length > 0) {\n    country = countries[0];\n  }\n\n  return country;\n}\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} includeInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\n\n\nfunction getCountrySelectOptions(countries, country_names, includeInternationalOption) {\n  // Generates a `<Select/>` option for each country.\n  var country_select_options = countries.map(function (country) {\n    return {\n      value: country,\n      label: country_names[country]\n    };\n  }); // Sort the list of countries alphabetically.\n\n  country_select_options.sort(function (a, b) {\n    return compare_strings(a.label, b.label);\n  }); // Add the \"International\" option to the country list (if suitable)\n\n  if (includeInternationalOption) {\n    country_select_options.unshift({\n      label: country_names.ZZ\n    });\n  }\n\n  return country_select_options;\n}\n/**\r\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\r\n * @param {string?} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n */\n\n\nfunction parsePhoneNumber(value, metadata) {\n  return (0, _core.parsePhoneNumberFromString)(value || '', metadata);\n}\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\n\n\nfunction generateNationalNumberDigits(phoneNumber) {\n  return phoneNumber.formatNational().replace(/\\D/g, '');\n}\n/**\r\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\r\n * @param {string?} value - The `value` parsed from phone number `<input/>` (it's the `parsed_input` state property, not the `value` property).\r\n * @param {string?} previousCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} preferNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string?}\r\n */\n\n\nfunction migrateParsedInputForNewCountry(value, previous_country, new_country, metadata, preferNationalFormat) {\n  // If `parsed_input` is empty\n  // then no need to migrate anything.\n  if (!value) {\n    return value;\n  } // If switching to some country.\n  // (from \"International\" or another country)\n  // If switching from \"International\" then `value` starts with a `+`.\n  // Otherwise it may or may not start with a `+`.\n\n\n  if (new_country) {\n    // If the phone number was entered in international format\n    // then migrate it to the newly selected country.\n    // The phone number may be incomplete.\n    // The phone number entered not necessarily starts with\n    // the previously selected country phone prefix.\n    if (value[0] === '+') {\n      // If the international phone number is for the new country\n      // then convert it to local if required.\n      if (preferNationalFormat) {\n        // // If a phone number is being input in international form\n        // // and the country can already be derived from it,\n        // // and if it is the new country, then format as a national number.\n        // const derived_country = get_country_from_possibly_incomplete_international_phone_number(value, metadata)\n        // if (derived_country === new_country)\n        // {\n        // \treturn strip_country_calling_code(value, derived_country, metadata)\n        // }\n        // Actually, the two countries don't necessarily need to match:\n        // the condition could be looser here, because several countries\n        // might share the same international phone number format\n        // (for example, \"NANPA\" countries like US, Canada, etc).\n        // The looser condition would be just \"same nternational phone number format\"\n        // which would mean \"same country calling code\" in the context of `libphonenumber-js`.\n        if (value.indexOf('+' + (0, _core.getCountryCallingCode)(new_country, metadata)) === 0) {\n          return strip_country_calling_code(value, new_country, metadata);\n        } // Simply discard the previously entered international phone number,\n        // because otherwise any \"smart\" transformation like getting the\n        // \"national (significant) number\" part and then prepending the\n        // newly selected country's \"country calling code\" to it\n        // would just be confusing for a user without being actually useful.\n\n\n        return ''; // // Simply strip the leading `+` character\n        // // therefore simply converting all digits into a \"local\" phone number.\n        // // https://github.com/catamphetamine/react-phone-number-input/issues/287\n        // return value.slice(1)\n      } // If the international phone number already contains\n      // any country calling code then trim the country calling code part.\n      // (that could also be the newly selected country phone code prefix as well)\n      // `value` doesn't neccessarily belong to `previous_country`.\n      // (e.g. if a user enters an international number\n      //  not belonging to any of the reduced `countries` list).\n\n\n      value = strip_country_calling_code(value, previous_country, metadata); // Prepend country calling code prefix\n      // for the newly selected country.\n\n      return e164(value, new_country, metadata) || '+' + (0, _core.getCountryCallingCode)(new_country, metadata);\n    }\n  } // If switching to \"International\" from a country.\n  else {\n      // If the phone number was entered in national format.\n      if (value[0] !== '+') {\n        // Format the national phone number as an international one.\n        // The phone number entered not necessarily even starts with\n        // the previously selected country phone prefix.\n        // Even if the phone number belongs to whole another country\n        // it will still be parsed into some national phone number.\n        return e164(value, previous_country, metadata) || '';\n      }\n    }\n\n  return value;\n}\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nfunction e164(number, country, metadata) {\n  if (!number) {\n    return;\n  } // If the phone number is being input in international format.\n\n\n  if (number[0] === '+') {\n    // If it's just the `+` sign then return nothing.\n    if (number === '+') {\n      return;\n    } // If there are any digits then the `value` is returned as is.\n\n\n    return number;\n  } // For non-international phone numbers\n  // an accompanying country code is required.\n\n\n  if (!country) {\n    return;\n  }\n\n  var partial_national_significant_number = get_national_significant_number_part(number, country, metadata);\n\n  if (partial_national_significant_number) {\n    return '+' + (0, _core.getCountryCallingCode)(country, metadata) + partial_national_significant_number;\n  }\n}\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\n\n\nfunction trimNumber(number, country, metadata) {\n  var nationalSignificantNumberPart = get_national_significant_number_part(number, country, metadata);\n  var overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata);\n\n  if (overflowDigitsCount > 0) {\n    return number.slice(0, number.length - overflowDigitsCount);\n  }\n\n  return number;\n}\n\nfunction getMaxNumberLength(country, metadata) {\n  // Get \"possible lengths\" for a phone number of the country.\n  metadata = new _core.Metadata(metadata);\n  metadata.country(country); // Return the last \"possible length\".\n\n  return metadata.possibleLengths()[metadata.possibleLengths().length - 1];\n} // If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n\n/**\r\n * @param {string} parsedInput - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nfunction getCountryForPartialE164Number(partialE164Number, country, countries, includeInternationalOption, metadata) {\n  if (partialE164Number === '+') {\n    // Don't change the currently selected country yet.\n    return country;\n  }\n\n  var derived_country = get_country_from_possibly_incomplete_international_phone_number(partialE164Number, metadata); // If a phone number is being input in international form\n  // and the country can already be derived from it,\n  // then select that country.\n\n  if (derived_country && (!countries || countries.indexOf(derived_country) >= 0)) {\n    return derived_country;\n  } // If \"International\" country option has not been disabled\n  // and the international phone number entered doesn't correspond\n  // to the currently selected country then reset the currently selected country.\n  else if (country && includeInternationalOption && !could_number_belong_to_country(partialE164Number, country, metadata)) {\n      return undefined;\n    } // Don't change the currently selected country.\n\n\n  return country;\n}\n/**\r\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\r\n * @param  {string?} input — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} prevInput — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} country - Currently selected country.\r\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {object} An object of shape `{ input, country, value }`.\r\n */\n\n\nfunction parseInput(input, prevInput, country, countries, includeInternationalOption, limitMaxLength, metadata) {\n  // Trim the input to not exceed the maximum possible number length.\n  if (input && country && limitMaxLength) {\n    input = trimNumber(input, country, metadata);\n  } // If this `onChange()` event was triggered\n  // as a result of selecting \"International\" country\n  // then force-prepend a `+` sign if the phone number\n  // `<input/>` value isn't in international format.\n\n\n  if (input && !country && input[0] !== '+') {\n    input = '+' + input;\n  } // If the previously entered phone number\n  // has been entered in international format\n  // and the user decides to erase it,\n  // then also reset the `country`\n  // because it was most likely automatically selected\n  // while the user was typing in the phone number\n  // in international format.\n  // This fixes the issue when a user is presented\n  // with a phone number input with no country selected\n  // and then types in their local phone number\n  // then discovers that the input's messed up\n  // (a `+` has been prepended at the start of their input\n  //  and a random country has been selected),\n  // decides to undo it all by erasing everything\n  // and then types in their local phone number again\n  // resulting in a seemingly correct phone number\n  // but in reality that phone number has incorrect country.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/273\n\n\n  if (!input && prevInput && prevInput[0] === '+') {\n    country = undefined;\n  } // Also resets such \"randomly\" selected country\n  // as soon as the user erases the number\n  // digit-by-digit up to the leading `+` sign.\n\n\n  if (input === '+' && prevInput && prevInput[0] === '+' && prevInput.length > '+'.length) {\n    country = undefined;\n  } // Generate the new `value` property.\n\n\n  var value = void 0;\n\n  if (input) {\n    if (input[0] === '+') {\n      if (input !== '+') {\n        value = input;\n      }\n    } else {\n      value = e164(input, country, metadata);\n    }\n  } // Derive the country from the phone number.\n  // (regardless of whether there's any country currently selected)\n\n\n  if (value) {\n    country = getCountryForPartialE164Number(value, country, countries, includeInternationalOption, metadata);\n  }\n\n  return {\n    input: input,\n    country: country,\n    value: value\n  };\n}\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nfunction get_country_from_possibly_incomplete_international_phone_number(number, metadata) {\n  var formatter = new _core.AsYouType(null, metadata);\n  formatter.input(number); // `001` is a special \"non-geograpical entity\" code\n  // in Google's `libphonenumber` library.\n\n  if (formatter.country === '001') {\n    return;\n  }\n\n  return formatter.country;\n}\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n */\n\n\nfunction compare_strings(a, b) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  // `localeCompare()` is available in latest Node.js versions.\n\n  /* istanbul ignore else */\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b);\n  }\n  /* istanbul ignore next */\n\n\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\n\n\nfunction strip_country_calling_code(number, country, metadata) {\n  // Just an optimization, so that it\n  // doesn't have to iterate through all country calling codes.\n  if (country) {\n    var country_calling_prefix = '+' + (0, _core.getCountryCallingCode)(country, metadata); // If `country` fits the actual `number`.\n\n    if (number.length < country_calling_prefix.length) {\n      if (country_calling_prefix.indexOf(number) === 0) {\n        return '';\n      }\n    } else {\n      if (number.indexOf(country_calling_prefix) === 0) {\n        return number.slice(country_calling_prefix.length);\n      }\n    }\n  } // If `country` doesn't fit the actual `number`.\n  // Try all available country calling codes.\n\n\n  for (var _iterator = Object.keys(metadata.country_calling_codes), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var country_calling_code = _ref;\n\n    if (number.indexOf(country_calling_code) === '+'.length) {\n      return number.slice('+'.length + country_calling_code.length);\n    }\n  }\n\n  return '';\n}\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\n\n\nfunction get_national_significant_number_part(number, country, metadata) {\n  // Create \"as you type\" formatter.\n  var formatter = new _core.AsYouType(country, metadata); // Input partial national phone number.\n\n  formatter.input(number); // Return the parsed partial national phone number.\n\n  return formatter.getNationalNumber();\n}\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\n\n\nfunction could_number_belong_to_country(number, country, metadata) {\n  var country_calling_code = (0, _core.getCountryCallingCode)(country, metadata);\n  var i = 0;\n\n  while (i + 1 < number.length && i < country_calling_code.length) {\n    if (number[i + 1] !== country_calling_code[i]) {\n      return false;\n    }\n\n    i++;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["../source/input-control.js"],"names":["getPreSelectedCountry","phoneNumber","country","countries","getCountrySelectOptions","country_select_options","value","label","country_names","compare_strings","a","b","ZZ","parsePhoneNumber","generateNationalNumberDigits","migrateParsedInputForNewCountry","strip_country_calling_code","e164","number","partial_national_significant_number","get_national_significant_number_part","trimNumber","nationalSignificantNumberPart","overflowDigitsCount","getMaxNumberLength","metadata","getCountryForPartialE164Number","partialE164Number","derived_country","get_country_from_possibly_incomplete_international_phone_number","could_number_belong_to_country","parseInput","input","prevInput","formatter","String","country_calling_prefix","country_calling_code","Object","i"],"mappings":"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","sourcesContent":["import {\r\n\tparsePhoneNumberFromString,\r\n\tgetCountryCallingCode,\r\n\tAsYouType,\r\n\tMetadata\r\n} from 'libphonenumber-js/core'\r\n\r\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\r\nexport function getPreSelectedCountry(phoneNumber, country, countries, includeInternationalOption, metadata)\r\n{\r\n\t// If can get country from E.164 phone number\r\n\t// then it overrides the `country` passed (or not passed).\r\n\tif (phoneNumber && phoneNumber.country)\r\n\t{\r\n\t\t// `country` will be left `undefined` in case of non-detection.\r\n\t\tcountry = phoneNumber.country\r\n\t}\r\n\r\n\t// Only pre-select a country if it's in the available `countries` list.\r\n\tif (countries && countries.indexOf(country) < 0)\r\n\t{\r\n\t\tcountry = undefined\r\n\t}\r\n\r\n\t// If there will be no \"International\" option\r\n\t// then some `country` must be selected.\r\n\t// It will still be the wrong country though.\r\n\t// But still country `<select/>` can't be left in a broken state.\r\n\tif (!country && !includeInternationalOption && countries && countries.length > 0)\r\n\t{\r\n\t\tcountry = countries[0]\r\n\t}\r\n\r\n\treturn country\r\n}\r\n\r\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} includeInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\r\nexport function getCountrySelectOptions(countries, country_names, includeInternationalOption)\r\n{\r\n\t// Generates a `<Select/>` option for each country.\r\n\tconst country_select_options = countries.map((country) =>\r\n\t({\r\n\t\tvalue : country,\r\n\t\tlabel : country_names[country]\r\n\t}))\r\n\r\n\t// Sort the list of countries alphabetically.\r\n\tcountry_select_options.sort((a, b) => compare_strings(a.label, b.label))\r\n\r\n\t// Add the \"International\" option to the country list (if suitable)\r\n\tif (includeInternationalOption)\r\n\t{\r\n\t\tcountry_select_options.unshift\r\n\t\t({\r\n\t\t\tlabel : country_names.ZZ\r\n\t\t})\r\n\t}\r\n\r\n\treturn country_select_options\r\n}\r\n\r\n/**\r\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\r\n * @param {string?} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n */\r\nexport function parsePhoneNumber(value, metadata)\r\n{\r\n\treturn parsePhoneNumberFromString(value || '', metadata)\r\n}\r\n\r\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\r\nexport function generateNationalNumberDigits(phoneNumber)\r\n{\r\n\treturn phoneNumber.formatNational().replace(/\\D/g, '')\r\n}\r\n\r\n/**\r\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\r\n * @param {string?} value - The `value` parsed from phone number `<input/>` (it's the `parsed_input` state property, not the `value` property).\r\n * @param {string?} previousCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} preferNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string?}\r\n */\r\nexport function migrateParsedInputForNewCountry\r\n(\r\n\tvalue,\r\n\tprevious_country,\r\n\tnew_country,\r\n\tmetadata,\r\n\tpreferNationalFormat\r\n)\r\n{\r\n\t// If `parsed_input` is empty\r\n\t// then no need to migrate anything.\r\n\tif (!value) {\r\n\t\treturn value\r\n\t}\r\n\r\n\t// If switching to some country.\r\n\t// (from \"International\" or another country)\r\n\t// If switching from \"International\" then `value` starts with a `+`.\r\n\t// Otherwise it may or may not start with a `+`.\r\n\tif (new_country)\r\n\t{\r\n\t\t// If the phone number was entered in international format\r\n\t\t// then migrate it to the newly selected country.\r\n\t\t// The phone number may be incomplete.\r\n\t\t// The phone number entered not necessarily starts with\r\n\t\t// the previously selected country phone prefix.\r\n\t\tif (value[0] === '+')\r\n\t\t{\r\n\t\t\t// If the international phone number is for the new country\r\n\t\t\t// then convert it to local if required.\r\n\t\t\tif (preferNationalFormat)\r\n\t\t\t{\r\n\t\t\t\t// // If a phone number is being input in international form\r\n\t\t\t\t// // and the country can already be derived from it,\r\n\t\t\t\t// // and if it is the new country, then format as a national number.\r\n\t\t\t\t// const derived_country = get_country_from_possibly_incomplete_international_phone_number(value, metadata)\r\n\t\t\t\t// if (derived_country === new_country)\r\n\t\t\t\t// {\r\n\t\t\t\t// \treturn strip_country_calling_code(value, derived_country, metadata)\r\n\t\t\t\t// }\r\n\r\n\t\t\t\t// Actually, the two countries don't necessarily need to match:\r\n\t\t\t\t// the condition could be looser here, because several countries\r\n\t\t\t\t// might share the same international phone number format\r\n\t\t\t\t// (for example, \"NANPA\" countries like US, Canada, etc).\r\n\t\t\t\t// The looser condition would be just \"same nternational phone number format\"\r\n\t\t\t\t// which would mean \"same country calling code\" in the context of `libphonenumber-js`.\r\n\t\t\t\tif (value.indexOf('+' + getCountryCallingCode(new_country, metadata)) === 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn strip_country_calling_code(value, new_country, metadata)\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Simply discard the previously entered international phone number,\r\n\t\t\t\t// because otherwise any \"smart\" transformation like getting the\r\n\t\t\t\t// \"national (significant) number\" part and then prepending the\r\n\t\t\t\t// newly selected country's \"country calling code\" to it\r\n\t\t\t\t// would just be confusing for a user without being actually useful.\r\n\t\t\t\treturn ''\r\n\r\n\t\t\t\t// // Simply strip the leading `+` character\r\n\t\t\t\t// // therefore simply converting all digits into a \"local\" phone number.\r\n\t\t\t\t// // https://github.com/catamphetamine/react-phone-number-input/issues/287\r\n\t\t\t\t// return value.slice(1)\r\n\t\t\t}\r\n\r\n\t\t\t// If the international phone number already contains\r\n\t\t\t// any country calling code then trim the country calling code part.\r\n\t\t\t// (that could also be the newly selected country phone code prefix as well)\r\n\t\t\t// `value` doesn't neccessarily belong to `previous_country`.\r\n\t\t\t// (e.g. if a user enters an international number\r\n\t\t\t//  not belonging to any of the reduced `countries` list).\r\n\t\t\tvalue = strip_country_calling_code(value, previous_country, metadata)\r\n\r\n\t\t\t// Prepend country calling code prefix\r\n\t\t\t// for the newly selected country.\r\n\t\t\treturn e164(value, new_country, metadata) || `+${getCountryCallingCode(new_country, metadata)}`\r\n\t\t}\r\n\t}\r\n\t// If switching to \"International\" from a country.\r\n\telse\r\n\t{\r\n\t\t// If the phone number was entered in national format.\r\n\t\tif (value[0] !== '+')\r\n\t\t{\r\n\t\t\t// Format the national phone number as an international one.\r\n\t\t\t// The phone number entered not necessarily even starts with\r\n\t\t\t// the previously selected country phone prefix.\r\n\t\t\t// Even if the phone number belongs to whole another country\r\n\t\t\t// it will still be parsed into some national phone number.\r\n\t\t\treturn e164(value, previous_country, metadata) || ''\r\n\t\t}\r\n\t}\r\n\r\n\treturn value\r\n}\r\n\r\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function e164(number, country, metadata)\r\n{\r\n\tif (!number) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// If the phone number is being input in international format.\r\n\tif (number[0] === '+')\r\n\t{\r\n\t\t// If it's just the `+` sign then return nothing.\r\n\t\tif (number === '+') {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// If there are any digits then the `value` is returned as is.\r\n\t\treturn number\r\n\t}\r\n\r\n\t// For non-international phone numbers\r\n\t// an accompanying country code is required.\r\n\tif (!country) {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst partial_national_significant_number = get_national_significant_number_part(number, country, metadata)\r\n\r\n\tif (partial_national_significant_number) {\r\n\t\treturn `+${getCountryCallingCode(country, metadata)}${partial_national_significant_number}`\r\n\t}\r\n}\r\n\r\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\r\nexport function trimNumber(number, country, metadata)\r\n{\r\n\tconst nationalSignificantNumberPart = get_national_significant_number_part(number, country, metadata)\r\n\tconst overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata)\r\n\tif (overflowDigitsCount > 0) {\r\n\t\treturn number.slice(0, number.length - overflowDigitsCount)\r\n\t}\r\n\treturn number\r\n}\r\n\r\nfunction getMaxNumberLength(country, metadata)\r\n{\r\n\t// Get \"possible lengths\" for a phone number of the country.\r\n\tmetadata = new Metadata(metadata)\r\n\tmetadata.country(country)\r\n\t// Return the last \"possible length\".\r\n\treturn metadata.possibleLengths()[metadata.possibleLengths().length - 1]\r\n}\r\n\r\n// If the phone number being input is an international one\r\n// then tries to derive the country from the phone number.\r\n// (regardless of whether there's any country currently selected)\r\n/**\r\n * @param {string} parsedInput - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function getCountryForPartialE164Number\r\n(\r\n\tpartialE164Number,\r\n\tcountry,\r\n\tcountries,\r\n\tincludeInternationalOption,\r\n\tmetadata\r\n)\r\n{\r\n\tif (partialE164Number === '+')\r\n\t{\r\n\t\t// Don't change the currently selected country yet.\r\n\t\treturn country\r\n\t}\r\n\r\n\tconst derived_country = get_country_from_possibly_incomplete_international_phone_number(partialE164Number, metadata)\r\n\r\n\t// If a phone number is being input in international form\r\n\t// and the country can already be derived from it,\r\n\t// then select that country.\r\n\tif (derived_country && (!countries || (countries.indexOf(derived_country) >= 0)))\r\n\t{\r\n\t\treturn derived_country\r\n\t}\r\n\t// If \"International\" country option has not been disabled\r\n\t// and the international phone number entered doesn't correspond\r\n\t// to the currently selected country then reset the currently selected country.\r\n\telse if (country &&\r\n\t\tincludeInternationalOption &&\r\n\t\t!could_number_belong_to_country(partialE164Number, country, metadata))\r\n\t{\r\n\t\treturn undefined\r\n\t}\r\n\r\n\t// Don't change the currently selected country.\r\n\treturn country\r\n}\r\n\r\n/**\r\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\r\n * @param  {string?} input — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} prevInput — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} country - Currently selected country.\r\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {object} An object of shape `{ input, country, value }`.\r\n */\r\nexport function parseInput(\r\n\tinput,\r\n\tprevInput,\r\n\tcountry,\r\n\tcountries,\r\n\tincludeInternationalOption,\r\n\tlimitMaxLength,\r\n\tmetadata\r\n) {\r\n\t// Trim the input to not exceed the maximum possible number length.\r\n\tif (input && country && limitMaxLength) {\r\n\t\tinput = trimNumber(input, country, metadata)\r\n\t}\r\n\r\n\t// If this `onChange()` event was triggered\r\n\t// as a result of selecting \"International\" country\r\n\t// then force-prepend a `+` sign if the phone number\r\n\t// `<input/>` value isn't in international format.\r\n\tif (input && !country && input[0] !== '+') {\r\n\t\tinput = '+' + input\r\n\t}\r\n\r\n\t// If the previously entered phone number\r\n\t// has been entered in international format\r\n\t// and the user decides to erase it,\r\n\t// then also reset the `country`\r\n\t// because it was most likely automatically selected\r\n\t// while the user was typing in the phone number\r\n\t// in international format.\r\n\t// This fixes the issue when a user is presented\r\n\t// with a phone number input with no country selected\r\n\t// and then types in their local phone number\r\n\t// then discovers that the input's messed up\r\n\t// (a `+` has been prepended at the start of their input\r\n\t//  and a random country has been selected),\r\n\t// decides to undo it all by erasing everything\r\n\t// and then types in their local phone number again\r\n\t// resulting in a seemingly correct phone number\r\n\t// but in reality that phone number has incorrect country.\r\n\t// https://github.com/catamphetamine/react-phone-number-input/issues/273\r\n\tif (!input && prevInput && prevInput[0] === '+') {\r\n\t\tcountry = undefined\r\n\t}\r\n\t// Also resets such \"randomly\" selected country\r\n\t// as soon as the user erases the number\r\n\t// digit-by-digit up to the leading `+` sign.\r\n\tif (input === '+' && prevInput && prevInput[0] === '+' && prevInput.length > '+'.length) {\r\n\t\tcountry = undefined\r\n\t}\r\n\r\n\t// Generate the new `value` property.\r\n\tlet value\r\n\tif (input) {\r\n\t\tif (input[0] === '+') {\r\n\t\t\tif (input !== '+') {\r\n\t\t\t\tvalue = input\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalue = e164(input, country, metadata)\r\n\t\t}\r\n\t}\r\n\r\n\t// Derive the country from the phone number.\r\n\t// (regardless of whether there's any country currently selected)\r\n\tif (value) {\r\n\t\tcountry = getCountryForPartialE164Number(\r\n\t\t\tvalue,\r\n\t\t\tcountry,\r\n\t\t\tcountries,\r\n\t\t\tincludeInternationalOption,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t}\r\n\r\n\treturn {\r\n\t\tinput,\r\n\t\tcountry,\r\n\t\tvalue\r\n\t}\r\n}\r\n\r\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function get_country_from_possibly_incomplete_international_phone_number(number, metadata)\r\n{\r\n\tconst formatter = new AsYouType(null, metadata)\r\n\tformatter.input(number)\r\n\t// `001` is a special \"non-geograpical entity\" code\r\n\t// in Google's `libphonenumber` library.\r\n\tif (formatter.country === '001') {\r\n\t\treturn\r\n\t}\r\n\treturn formatter.country\r\n}\r\n\r\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n */\r\nexport function compare_strings(a, b) {\r\n  // Use `String.localeCompare` if it's available.\r\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\r\n  // Which means everyone except IE <= 10 and Safari <= 10.\r\n  // `localeCompare()` is available in latest Node.js versions.\r\n  /* istanbul ignore else */\r\n  if (String.prototype.localeCompare) {\r\n    return a.localeCompare(b);\r\n  }\r\n  /* istanbul ignore next */\r\n  return a < b ? -1 : (a > b ? 1 : 0);\r\n}\r\n\r\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\r\nexport function strip_country_calling_code(number, country, metadata)\r\n{\r\n\t// Just an optimization, so that it\r\n\t// doesn't have to iterate through all country calling codes.\r\n\tif (country)\r\n\t{\r\n\t\tconst country_calling_prefix = '+' + getCountryCallingCode(country, metadata)\r\n\r\n\t\t// If `country` fits the actual `number`.\r\n\t\tif (number.length < country_calling_prefix.length)\r\n\t\t{\r\n\t\t\tif (country_calling_prefix.indexOf(number) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (number.indexOf(country_calling_prefix) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn number.slice(country_calling_prefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If `country` doesn't fit the actual `number`.\r\n\t// Try all available country calling codes.\r\n\tfor (const country_calling_code of Object.keys(metadata.country_calling_codes))\r\n\t{\r\n\t\tif (number.indexOf(country_calling_code) === '+'.length)\r\n\t\t{\r\n\t\t\treturn number.slice('+'.length + country_calling_code.length)\r\n\t\t}\r\n\t}\r\n\r\n\treturn ''\r\n}\r\n\r\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\r\nexport function get_national_significant_number_part(number, country, metadata)\r\n{\r\n\t// Create \"as you type\" formatter.\r\n\tconst formatter = new AsYouType(country, metadata)\r\n\r\n\t// Input partial national phone number.\r\n\tformatter.input(number)\r\n\r\n\t// Return the parsed partial national phone number.\r\n\treturn formatter.getNationalNumber()\r\n}\r\n\r\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\r\nexport function could_number_belong_to_country(number, country, metadata)\r\n{\r\n\tconst country_calling_code = getCountryCallingCode(country, metadata)\r\n\r\n\tlet i = 0\r\n\twhile (i + 1 < number.length && i < country_calling_code.length)\r\n\t{\r\n\t\tif (number[i + 1] !== country_calling_code[i])\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn true\r\n}"]},"metadata":{},"sourceType":"script"}