{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parse; // Parses the `text`.\n//\n// Returns `{ value, caret }` where `caret` is\n// the caret position inside `value`\n// corresponding to the `caret_position` inside `text`.\n//\n// The `text` is parsed by feeding each character sequentially to\n// `parse_character(character, value)` function\n// and appending the result (if it's not `undefined`) to `value`.\n//\n// Example:\n//\n// `text` is `8 (800) 555-35-35`,\n// `caret_position` is `4` (before the first `0`).\n// `parse_character` is `(character, value) =>\n//   if (character >= '0' && character <= '9') { return character }`.\n//\n// then `parse()` outputs `{ value: '88005553535', caret: 2 }`.\n//\n\nfunction parse(text, caret_position, parse_character) {\n  var value = '';\n  var focused_input_character_index = 0;\n  var index = 0;\n\n  while (index < text.length) {\n    var character = parse_character(text[index], value);\n\n    if (character !== undefined) {\n      value += character;\n\n      if (caret_position !== undefined) {\n        if (caret_position === index) {\n          focused_input_character_index = value.length - 1;\n        } else if (caret_position > index) {\n          focused_input_character_index = value.length;\n        }\n      }\n    }\n\n    index++;\n  } // If caret position wasn't specified\n\n\n  if (caret_position === undefined) {\n    // Then set caret position to \"after the last input character\"\n    focused_input_character_index = value.length;\n  }\n\n  var result = {\n    value: value,\n    caret: focused_input_character_index\n  };\n  return result;\n}","map":{"version":3,"sources":["../source/parse.js"],"names":["parse","value","focused_input_character_index","index","text","character","parse_character","caret_position","result","caret"],"mappings":";;;;;kBAmBwBA,K,EAnBxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACe,SAAA,KAAA,CAAA,IAAA,EAAA,cAAA,EAAA,eAAA,EACf;AACC,MAAIC,KAAAA,GAAJ,EAAA;AAEA,MAAIC,6BAAAA,GAAJ,CAAA;AAEA,MAAIC,KAAAA,GAAJ,CAAA;;AACA,SAAOA,KAAAA,GAAQC,IAAAA,CAAf,MAAA,EACA;AACC,QAAMC,SAAAA,GAAYC,eAAAA,CAAgBF,IAAAA,CAAhBE,KAAgBF,CAAhBE,EAAlB,KAAkBA,CAAlB;;AAEA,QAAID,SAAAA,KAAJ,SAAA,EACA;AACCJ,MAAAA,KAAAA,IAAAA,SAAAA;;AAEA,UAAIM,cAAAA,KAAJ,SAAA,EACA;AACC,YAAIA,cAAAA,KAAJ,KAAA,EACA;AACCL,UAAAA,6BAAAA,GAAgCD,KAAAA,CAAAA,MAAAA,GAAhCC,CAAAA;AAFD,SAAA,MAIK,IAAIK,cAAAA,GAAJ,KAAA,EACL;AACCL,UAAAA,6BAAAA,GAAgCD,KAAAA,CAAhCC,MAAAA;AACA;AACA;AACF;;AAEDC,IAAAA,KAAAA;AACA,GA5BF,CA8BC;;;AACA,MAAII,cAAAA,KAAJ,SAAA,EACA;AACC;AACAL,IAAAA,6BAAAA,GAAgCD,KAAAA,CAAhCC,MAAAA;AACA;;AAED,MAAMM,MAAAA,GACN;AACCP,IAAAA,KAAAA,EADD,KAAA;AAECQ,IAAAA,KAAAA,EAAQP;AAFT,GADA;AAMA,SAAA,MAAA;AACA","sourcesContent":["// Parses the `text`.\r\n//\r\n// Returns `{ value, caret }` where `caret` is\r\n// the caret position inside `value`\r\n// corresponding to the `caret_position` inside `text`.\r\n//\r\n// The `text` is parsed by feeding each character sequentially to\r\n// `parse_character(character, value)` function\r\n// and appending the result (if it's not `undefined`) to `value`.\r\n//\r\n// Example:\r\n//\r\n// `text` is `8 (800) 555-35-35`,\r\n// `caret_position` is `4` (before the first `0`).\r\n// `parse_character` is `(character, value) =>\r\n//   if (character >= '0' && character <= '9') { return character }`.\r\n//\r\n// then `parse()` outputs `{ value: '88005553535', caret: 2 }`.\r\n//\r\nexport default function parse(text, caret_position, parse_character)\r\n{\r\n\tlet value = ''\r\n\r\n\tlet focused_input_character_index = 0\r\n\r\n\tlet index = 0\r\n\twhile (index < text.length)\r\n\t{\r\n\t\tconst character = parse_character(text[index], value)\r\n\r\n\t\tif (character !== undefined)\r\n\t\t{\r\n\t\t\tvalue += character\r\n\r\n\t\t\tif (caret_position !== undefined)\r\n\t\t\t{\r\n\t\t\t\tif (caret_position === index)\r\n\t\t\t\t{\r\n\t\t\t\t\tfocused_input_character_index = value.length - 1;\r\n\t\t\t\t}\r\n\t\t\t\telse if (caret_position > index)\r\n\t\t\t\t{\r\n\t\t\t\t\tfocused_input_character_index = value.length\r\n\t\t\t\t}\r\n\t\t\t }\r\n\t\t}\r\n\r\n\t\tindex++\r\n\t}\r\n\r\n\t// If caret position wasn't specified\r\n\tif (caret_position === undefined)\r\n\t{\r\n\t\t// Then set caret position to \"after the last input character\"\r\n\t\tfocused_input_character_index = value.length\r\n\t}\r\n\r\n\tconst result =\r\n\t{\r\n\t\tvalue,\r\n\t\tcaret : focused_input_character_index\r\n\t}\r\n\r\n\treturn result\r\n}"]},"metadata":{},"sourceType":"script"}