{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n}; // This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\n\nimport { VALID_PUNCTUATION } from './constants';\nimport { matchesEntirely } from './util';\nimport Metadata from './metadata';\nimport { getIDDPrefix } from './IDD';\nimport { formatRFC3966 } from './RFC3966';\nvar defaultOptions = {\n  formatExtension: function formatExtension(formattedNumber, extension, metadata) {\n    return '' + formattedNumber + metadata.ext() + extension;\n  } // Formats a phone number\n  //\n  // Example use cases:\n  //\n  // ```js\n  // formatNumber('8005553535', 'RU', 'INTERNATIONAL')\n  // formatNumber('8005553535', 'RU', 'INTERNATIONAL', metadata)\n  // formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL')\n  // formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', metadata)\n  // formatNumber('+78005553535', 'NATIONAL')\n  // formatNumber('+78005553535', 'NATIONAL', metadata)\n  // ```\n  //\n\n};\nexport default function formatNumber(input, format, options, metadata) {\n  // Apply default options.\n  if (options) {\n    options = _extends({}, defaultOptions, options);\n  } else {\n    options = defaultOptions;\n  }\n\n  metadata = new Metadata(metadata);\n\n  if (input.country) {\n    // Validate `input.country`.\n    if (!metadata.hasCountry(input.country)) {\n      throw new Error('Unknown country: ' + input.country);\n    }\n\n    metadata.country(input.country);\n  } else if (input.countryCallingCode) {\n    metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);\n  } else return input.phone || '';\n\n  var countryCallingCode = metadata.countryCallingCode();\n  var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // This variable should have been declared inside `case`s\n  // but Babel has a bug and it says \"duplicate variable declaration\".\n\n  var number = void 0;\n\n  switch (format) {\n    case 'NATIONAL':\n      // Legacy argument support.\n      // (`{ country: ..., phone: '' }`)\n      if (!nationalNumber) {\n        return '';\n      }\n\n      number = format_national_number(nationalNumber, 'NATIONAL', metadata);\n      return addExtension(number, input.ext, metadata, options.formatExtension);\n\n    case 'INTERNATIONAL':\n      // Legacy argument support.\n      // (`{ country: ..., phone: '' }`)\n      if (!nationalNumber) {\n        return '+' + countryCallingCode;\n      }\n\n      number = format_national_number(nationalNumber, 'INTERNATIONAL', metadata);\n      number = '+' + countryCallingCode + ' ' + number;\n      return addExtension(number, input.ext, metadata, options.formatExtension);\n\n    case 'E.164':\n      // `E.164` doesn't define \"phone number extensions\".\n      return '+' + countryCallingCode + nationalNumber;\n\n    case 'RFC3966':\n      return formatRFC3966({\n        number: '+' + countryCallingCode + nationalNumber,\n        ext: input.ext\n      });\n\n    case 'IDD':\n      if (!options.fromCountry) {\n        return; // throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')\n      }\n\n      var IDDPrefix = getIDDPrefix(options.fromCountry, metadata.metadata);\n\n      if (!IDDPrefix) {\n        return;\n      }\n\n      if (options.humanReadable) {\n        var formattedForSameCountryCallingCode = countryCallingCode && formatIDDSameCountryCallingCodeNumber(nationalNumber, metadata.countryCallingCode(), options.fromCountry, metadata);\n\n        if (formattedForSameCountryCallingCode) {\n          number = formattedForSameCountryCallingCode;\n        } else {\n          number = IDDPrefix + ' ' + countryCallingCode + ' ' + format_national_number(nationalNumber, 'INTERNATIONAL', metadata);\n        }\n\n        return addExtension(number, input.ext, metadata, options.formatExtension);\n      }\n\n      return '' + IDDPrefix + countryCallingCode + nationalNumber;\n\n    default:\n      throw new Error('Unknown \"format\" argument passed to \"formatNumber()\": \"' + format + '\"');\n  }\n} // This was originally set to $1 but there are some countries for which the\n// first group is not used in the national pattern (e.g. Argentina) so the $1\n// group does not match correctly.  Therefore, we use \\d, so that the first\n// group actually used in the pattern will be matched.\n\nexport var FIRST_GROUP_PATTERN = /(\\$\\d)/;\nexport function format_national_number_using_format(number, format, useInternationalFormat, includeNationalPrefixForNationalFormat, metadata) {\n  var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() : format.nationalPrefixFormattingRule() && (!format.nationalPrefixIsOptionalWhenFormatting() || includeNationalPrefixForNationalFormat) ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());\n\n  if (useInternationalFormat) {\n    return changeInternationalFormatStyle(formattedNumber);\n  }\n\n  return formattedNumber;\n}\n\nfunction format_national_number(number, format_as, metadata) {\n  var format = choose_format_for_number(metadata.formats(), number);\n\n  if (!format) {\n    return number;\n  }\n\n  return format_national_number_using_format(number, format, format_as === 'INTERNATIONAL', true, metadata);\n}\n\nexport function choose_format_for_number(available_formats, national_number) {\n  for (var _iterator = available_formats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var format = _ref; // Validate leading digits\n\n    if (format.leadingDigitsPatterns().length > 0) {\n      // The last leading_digits_pattern is used here, as it is the most detailed\n      var last_leading_digits_pattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]; // If leading digits don't match then move on to the next phone number format\n\n      if (national_number.search(last_leading_digits_pattern) !== 0) {\n        continue;\n      }\n    } // Check that the national number matches the phone number format regular expression\n\n\n    if (matchesEntirely(national_number, format.pattern())) {\n      return format;\n    }\n  }\n} // Removes brackets and replaces dashes with spaces.\n//\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\n//\n// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.\n// Meanwhile, there's no single opinion about using punctuation in international phone numbers.\n//\n// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.\n// And here's a quote from WikiPedia's \"North American Numbering Plan\" page:\n// https://en.wikipedia.org/wiki/North_American_Numbering_Plan\n//\n// \"The country calling code for all countries participating in the NANP is 1.\n// In international format, an NANP number should be listed as +1 301 555 01 00,\n// where 301 is an area code (Maryland).\"\n//\n// I personally prefer the international format without any punctuation.\n// For example, brackets are remnants of the old age, meaning that the\n// phone number part in brackets (so called \"area code\") can be omitted\n// if dialing within the same \"area\".\n// And hyphens were clearly introduced for splitting local numbers into memorizable groups.\n// For example, remembering \"5553535\" is difficult but \"555-35-35\" is much simpler.\n// Imagine a man taking a bus from home to work and seeing an ad with a phone number.\n// He has a couple of seconds to memorize that number until it passes by.\n// If it were spaces instead of hyphens the man wouldn't necessarily get it,\n// but with hyphens instead of spaces the grouping is more explicit.\n// I personally think that hyphens introduce visual clutter,\n// so I prefer replacing them with spaces in international numbers.\n// In the modern age all output is done on displays where spaces are clearly distinguishable\n// so hyphens can be safely replaced with spaces without losing any legibility.\n//\n\nexport function changeInternationalFormatStyle(local) {\n  return local.replace(new RegExp('[' + VALID_PUNCTUATION + ']+', 'g'), ' ').trim();\n}\n\nfunction addExtension(formattedNumber, ext, metadata, formatExtension) {\n  return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;\n}\n\nexport function formatIDDSameCountryCallingCodeNumber(number, toCountryCallingCode, fromCountry, toCountryMetadata) {\n  var fromCountryMetadata = new Metadata(toCountryMetadata.metadata);\n  fromCountryMetadata.country(fromCountry); // If calling within the same country calling code.\n\n  if (toCountryCallingCode === fromCountryMetadata.countryCallingCode()) {\n    // For NANPA regions, return the national format for these regions\n    // but prefix it with the country calling code.\n    if (toCountryCallingCode === '1') {\n      return toCountryCallingCode + ' ' + format_national_number(number, 'NATIONAL', toCountryMetadata);\n    } // If regions share a country calling code, the country calling code need\n    // not be dialled. This also applies when dialling within a region, so this\n    // if clause covers both these cases. Technically this is the case for\n    // dialling from La Reunion to other overseas departments of France (French\n    // Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover\n    // this edge case for now and for those cases return the version including\n    // country calling code. Details here:\n    // http://www.petitfute.com/voyage/225-info-pratiques-reunion\n    //\n\n\n    return format_national_number(number, 'NATIONAL', toCountryMetadata);\n  }\n}","map":{"version":3,"sources":["../source/format_.js"],"names":["defaultOptions","formatExtension","metadata","options","input","countryCallingCode","nationalNumber","number","format_national_number","addExtension","ext","IDDPrefix","getIDDPrefix","formattedForSameCountryCallingCode","formatIDDSameCountryCallingCodeNumber","FIRST_GROUP_PATTERN","formattedNumber","format","useInternationalFormat","changeInternationalFormatStyle","choose_format_for_number","format_national_number_using_format","format_as","last_leading_digits_pattern","national_number","matchesEntirely","local","fromCountryMetadata","toCountryMetadata","toCountryCallingCode"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport { VALID_PUNCTUATION } from './constants'\r\nimport { matchesEntirely } from './util'\r\nimport Metadata from './metadata'\r\nimport { getIDDPrefix } from './IDD'\r\nimport { formatRFC3966 } from './RFC3966'\r\n\r\nconst defaultOptions =\r\n{\r\n\tformatExtension: (formattedNumber, extension, metadata) => `${formattedNumber}${metadata.ext()}${extension}`\r\n}\r\n\r\n// Formats a phone number\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// formatNumber('8005553535', 'RU', 'INTERNATIONAL')\r\n// formatNumber('8005553535', 'RU', 'INTERNATIONAL', metadata)\r\n// formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL')\r\n// formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', metadata)\r\n// formatNumber('+78005553535', 'NATIONAL')\r\n// formatNumber('+78005553535', 'NATIONAL', metadata)\r\n// ```\r\n//\r\nexport default function formatNumber(input, format, options, metadata)\r\n{\r\n\t// Apply default options.\r\n\tif (options) {\r\n\t\toptions = { ...defaultOptions, ...options }\r\n\t} else {\r\n\t\toptions = defaultOptions\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (input.country)\r\n\t{\r\n\t\t// Validate `input.country`.\r\n\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t}\r\n\t\tmetadata.country(input.country)\r\n\t}\r\n\telse if (input.countryCallingCode)\r\n\t{\r\n\t\tmetadata.chooseCountryByCountryCallingCode(input.countryCallingCode)\r\n\t}\r\n\telse return input.phone || ''\r\n\r\n\tconst countryCallingCode = metadata.countryCallingCode()\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// This variable should have been declared inside `case`s\r\n\t// but Babel has a bug and it says \"duplicate variable declaration\".\r\n\tlet number\r\n\r\n\tswitch (format)\r\n\t{\r\n\t\tcase 'NATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t\tnumber = format_national_number(nationalNumber, 'NATIONAL', metadata)\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'INTERNATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn `+${countryCallingCode}`\r\n\t\t\t}\r\n\t\t\tnumber = format_national_number(nationalNumber, 'INTERNATIONAL', metadata)\r\n\t\t\tnumber = `+${countryCallingCode} ${number}`\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'E.164':\r\n\t\t\t// `E.164` doesn't define \"phone number extensions\".\r\n\t\t\treturn `+${countryCallingCode}${nationalNumber}`\r\n\r\n\t\tcase 'RFC3966':\r\n\t\t\treturn formatRFC3966\r\n\t\t\t({\r\n\t\t\t\tnumber : `+${countryCallingCode}${nationalNumber}`,\r\n\t\t\t\text    : input.ext\r\n\t\t\t})\r\n\r\n\t\tcase 'IDD':\r\n\t\t\tif (!options.fromCountry) {\r\n\t\t\t\treturn\r\n\t\t\t\t// throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')\r\n\t\t\t}\r\n\t\t\tconst IDDPrefix = getIDDPrefix(options.fromCountry, metadata.metadata)\r\n\t\t\tif (!IDDPrefix) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (options.humanReadable)\r\n\t\t\t{\r\n\t\t\t\tconst formattedForSameCountryCallingCode = countryCallingCode && formatIDDSameCountryCallingCodeNumber(nationalNumber, metadata.countryCallingCode(), options.fromCountry, metadata)\r\n\t\t\t\tif (formattedForSameCountryCallingCode) {\r\n\t\t\t\t\tnumber = formattedForSameCountryCallingCode\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnumber = `${IDDPrefix} ${countryCallingCode} ${format_national_number(nationalNumber, 'INTERNATIONAL', metadata)}`\r\n\t\t\t\t}\r\n\t\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\t\t\t}\r\n\t\t\treturn `${IDDPrefix}${countryCallingCode}${nationalNumber}`\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unknown \"format\" argument passed to \"formatNumber()\": \"${format}\"`)\r\n\t}\r\n}\r\n\r\n// This was originally set to $1 but there are some countries for which the\r\n// first group is not used in the national pattern (e.g. Argentina) so the $1\r\n// group does not match correctly.  Therefore, we use \\d, so that the first\r\n// group actually used in the pattern will be matched.\r\nexport const FIRST_GROUP_PATTERN = /(\\$\\d)/\r\n\r\nexport function format_national_number_using_format(number, format, useInternationalFormat, includeNationalPrefixForNationalFormat, metadata)\r\n{\r\n\tconst formattedNumber = number.replace(\r\n\t\tnew RegExp(format.pattern()),\r\n\t\tuseInternationalFormat ?\r\n\t\t\tformat.internationalFormat() :\r\n\t\t\tformat.nationalPrefixFormattingRule() && (!format.nationalPrefixIsOptionalWhenFormatting() || includeNationalPrefixForNationalFormat) ?\r\n\t\t\t\tformat.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) :\r\n\t\t\t\tformat.format()\r\n\t)\r\n\r\n\tif (useInternationalFormat) {\r\n\t\treturn changeInternationalFormatStyle(formattedNumber)\r\n\t}\r\n\r\n\treturn formattedNumber\r\n}\r\n\r\nfunction format_national_number(number, format_as, metadata)\r\n{\r\n\tconst format = choose_format_for_number(metadata.formats(), number)\r\n\tif (!format) {\r\n\t\treturn number\r\n\t}\r\n\treturn format_national_number_using_format(number, format, format_as === 'INTERNATIONAL', true, metadata)\r\n}\r\n\r\nexport function choose_format_for_number(available_formats, national_number)\r\n{\r\n\tfor (const format of available_formats)\r\n\t{\r\n\t\t// Validate leading digits\r\n\t\tif (format.leadingDigitsPatterns().length > 0)\r\n\t\t{\r\n\t\t\t// The last leading_digits_pattern is used here, as it is the most detailed\r\n\t\t\tconst last_leading_digits_pattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]\r\n\r\n\t\t\t// If leading digits don't match then move on to the next phone number format\r\n\t\t\tif (national_number.search(last_leading_digits_pattern) !== 0)\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check that the national number matches the phone number format regular expression\r\n\t\tif (matchesEntirely(national_number, format.pattern()))\r\n\t\t{\r\n\t\t\treturn format\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Removes brackets and replaces dashes with spaces.\r\n//\r\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\r\n//\r\n// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.\r\n// Meanwhile, there's no single opinion about using punctuation in international phone numbers.\r\n//\r\n// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.\r\n// And here's a quote from WikiPedia's \"North American Numbering Plan\" page:\r\n// https://en.wikipedia.org/wiki/North_American_Numbering_Plan\r\n//\r\n// \"The country calling code for all countries participating in the NANP is 1.\r\n// In international format, an NANP number should be listed as +1 301 555 01 00,\r\n// where 301 is an area code (Maryland).\"\r\n//\r\n// I personally prefer the international format without any punctuation.\r\n// For example, brackets are remnants of the old age, meaning that the\r\n// phone number part in brackets (so called \"area code\") can be omitted\r\n// if dialing within the same \"area\".\r\n// And hyphens were clearly introduced for splitting local numbers into memorizable groups.\r\n// For example, remembering \"5553535\" is difficult but \"555-35-35\" is much simpler.\r\n// Imagine a man taking a bus from home to work and seeing an ad with a phone number.\r\n// He has a couple of seconds to memorize that number until it passes by.\r\n// If it were spaces instead of hyphens the man wouldn't necessarily get it,\r\n// but with hyphens instead of spaces the grouping is more explicit.\r\n// I personally think that hyphens introduce visual clutter,\r\n// so I prefer replacing them with spaces in international numbers.\r\n// In the modern age all output is done on displays where spaces are clearly distinguishable\r\n// so hyphens can be safely replaced with spaces without losing any legibility.\r\n//\r\nexport function changeInternationalFormatStyle(local)\r\n{\r\n\treturn local.replace(new RegExp(`[${VALID_PUNCTUATION}]+`, 'g'), ' ').trim()\r\n}\r\n\r\nfunction addExtension(formattedNumber, ext, metadata, formatExtension)\r\n{\r\n\treturn ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber\r\n}\r\n\r\nexport function formatIDDSameCountryCallingCodeNumber(number, toCountryCallingCode, fromCountry, toCountryMetadata)\r\n{\r\n\tconst fromCountryMetadata = new Metadata(toCountryMetadata.metadata)\r\n\tfromCountryMetadata.country(fromCountry)\r\n\r\n\t// If calling within the same country calling code.\r\n\tif (toCountryCallingCode === fromCountryMetadata.countryCallingCode())\r\n\t{\r\n\t\t// For NANPA regions, return the national format for these regions\r\n\t\t// but prefix it with the country calling code.\r\n\t\tif (toCountryCallingCode === '1')\r\n\t\t{\r\n\t\t\treturn toCountryCallingCode + ' ' + format_national_number(number, 'NATIONAL', toCountryMetadata)\r\n\t\t}\r\n\r\n\t\t// If regions share a country calling code, the country calling code need\r\n\t\t// not be dialled. This also applies when dialling within a region, so this\r\n\t\t// if clause covers both these cases. Technically this is the case for\r\n\t\t// dialling from La Reunion to other overseas departments of France (French\r\n\t\t// Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover\r\n\t\t// this edge case for now and for those cases return the version including\r\n\t\t// country calling code. Details here:\r\n\t\t// http://www.petitfute.com/voyage/225-info-pratiques-reunion\r\n\t\t//\r\n\t\treturn format_national_number(number, 'NATIONAL', toCountryMetadata)\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}