{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = format;\n\nvar _templateFormatter = require('./template formatter');\n\nvar _templateFormatter2 = _interopRequireDefault(_templateFormatter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Formats `value` value preserving `caret` at the same character.\n//\n// `{ value, caret }` attribute is the result of `parse()` function call.\n//\n// Returns `{ text, caret }` where the new `caret` is the caret position\n// inside `text` text corresponding to the original `caret` position inside `value`.\n//\n// `formatter(value)` is a function returning `{ text, template }`.\n//\n// `text` is the `value` value formatted using `template`.\n// It may either cut off the non-filled right part of the `template`\n// or it may fill the non-filled character placeholders\n// in the right part of the `template` with `spacer`\n// which is a space (' ') character by default.\n//\n// `template` is the template used to format the `value`.\n// It can be either a full-length template or a partial template.\n//\n// `formatter` can also be a string — a `template`\n// where character placeholders are denoted by 'x'es.\n// In this case `formatter` function is automatically created.\n//\n// Example:\n//\n// `value` is '880',\n// `caret` is `2` (before the first `0`)\n//\n// `formatter` is `'880' =>\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\n//\n// The result is `{ text: '8 (80 )', caret: 4 }`.\n//\n\n\nfunction format(value, caret, formatter) {\n  if (typeof formatter === 'string') {\n    formatter = (0, _templateFormatter2.default)(formatter);\n  }\n\n  var _ref = formatter(value) || {},\n      text = _ref.text,\n      template = _ref.template;\n\n  if (text === undefined) {\n    text = value;\n  }\n\n  if (template) {\n    if (caret === undefined) {\n      caret = text.length;\n    } else {\n      var index = 0;\n      var found = false;\n      var possibly_last_input_character_index = -1;\n\n      while (index < text.length && index < template.length) {\n        // Character placeholder found\n        if (text[index] !== template[index]) {\n          if (caret === 0) {\n            found = true;\n            caret = index;\n            break;\n          }\n\n          possibly_last_input_character_index = index;\n          caret--;\n        }\n\n        index++;\n      } // If the caret was positioned after last input character,\n      // then the text caret index is just after the last input character.\n\n\n      if (!found) {\n        caret = possibly_last_input_character_index + 1;\n      }\n    }\n  }\n\n  return {\n    text: text,\n    caret: caret\n  };\n}","map":{"version":3,"sources":["../source/format.js"],"names":["format","formatter","text","template","caret","index","found","possibly_last_input_character_index"],"mappings":";;;;;kBAkCwBA,M;;AAlCxB,IAAA,kBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;;;;;;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAAA,MAAA,CAAA,KAAA,EAAA,KAAA,EAAA,SAAA,EACf;AACC,MAAI,OAAA,SAAA,KAAJ,QAAA,EACA;AACCC,IAAAA,SAAAA,GAAY,CAAA,GAAA,mBAAA,CAAA,OAAA,EAAZA,SAAY,CAAZA;AACA;;AAJF,MAAA,IAAA,GAM0BA,SAAAA,CAAAA,KAAAA,CAAAA,IAN1B,EAAA;AAAA,MAMOC,IANP,GAAA,IAAA,CAAA,IAAA;AAAA,MAMaC,QANb,GAAA,IAAA,CAAA,QAAA;;AAQC,MAAID,IAAAA,KAAJ,SAAA,EACA;AACEA,IAAAA,IAAAA,GAAAA,KAAAA;AACD;;AAED,MAAA,QAAA,EACA;AACC,QAAIE,KAAAA,KAAJ,SAAA,EACA;AACCA,MAAAA,KAAAA,GAAQF,IAAAA,CAARE,MAAAA;AAFD,KAAA,MAKA;AACC,UAAIC,KAAAA,GAAJ,CAAA;AACA,UAAIC,KAAAA,GAAJ,KAAA;AAEA,UAAIC,mCAAAA,GAAsC,CAA1C,CAAA;;AAEA,aAAOF,KAAAA,GAAQH,IAAAA,CAARG,MAAAA,IAAuBA,KAAAA,GAAQF,QAAAA,CAAtC,MAAA,EACA;AACC;AACA,YAAID,IAAAA,CAAAA,KAAAA,CAAAA,KAAgBC,QAAAA,CAApB,KAAoBA,CAApB,EACA;AACC,cAAIC,KAAAA,KAAJ,CAAA,EACA;AACCE,YAAAA,KAAAA,GAAAA,IAAAA;AACAF,YAAAA,KAAAA,GAAAA,KAAAA;AACA;AACA;;AAEDG,UAAAA,mCAAAA,GAAAA,KAAAA;AAEAH,UAAAA,KAAAA;AACA;;AAEDC,QAAAA,KAAAA;AACA,OAxBF,CA0BC;AACA;;;AACA,UAAI,CAAJ,KAAA,EACA;AACCD,QAAAA,KAAAA,GAAQG,mCAAAA,GAARH,CAAAA;AACA;AACD;AACD;;AAED,SAAO;AAAEF,IAAAA,IAAAA,EAAF,IAAA;AAAQE,IAAAA,KAAAA,EAAf;AAAO,GAAP;AACA","sourcesContent":["import template_formatter from './template formatter'\r\n\r\n// Formats `value` value preserving `caret` at the same character.\r\n//\r\n// `{ value, caret }` attribute is the result of `parse()` function call.\r\n//\r\n// Returns `{ text, caret }` where the new `caret` is the caret position\r\n// inside `text` text corresponding to the original `caret` position inside `value`.\r\n//\r\n// `formatter(value)` is a function returning `{ text, template }`.\r\n//\r\n// `text` is the `value` value formatted using `template`.\r\n// It may either cut off the non-filled right part of the `template`\r\n// or it may fill the non-filled character placeholders\r\n// in the right part of the `template` with `spacer`\r\n// which is a space (' ') character by default.\r\n//\r\n// `template` is the template used to format the `value`.\r\n// It can be either a full-length template or a partial template.\r\n//\r\n// `formatter` can also be a string — a `template`\r\n// where character placeholders are denoted by 'x'es.\r\n// In this case `formatter` function is automatically created.\r\n//\r\n// Example:\r\n//\r\n// `value` is '880',\r\n// `caret` is `2` (before the first `0`)\r\n//\r\n// `formatter` is `'880' =>\r\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\r\n//\r\n// The result is `{ text: '8 (80 )', caret: 4 }`.\r\n//\r\nexport default function format(value, caret, formatter)\r\n{\r\n\tif (typeof formatter === 'string')\r\n\t{\r\n\t\tformatter = template_formatter(formatter)\r\n\t}\r\n\r\n\tlet { text, template } = formatter(value) || {}\r\n\r\n\tif (text === undefined)\r\n\t{\r\n\t\t text = value\r\n\t}\r\n\r\n\tif (template)\r\n\t{\r\n\t\tif (caret === undefined)\r\n\t\t{\r\n\t\t\tcaret = text.length\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet index = 0\r\n\t\t\tlet found = false\r\n\r\n\t\t\tlet possibly_last_input_character_index = -1\r\n\r\n\t\t\twhile (index < text.length && index < template.length)\r\n\t\t\t{\r\n\t\t\t\t// Character placeholder found\r\n\t\t\t\tif (text[index] !== template[index])\r\n\t\t\t\t{\r\n\t\t\t\t\tif (caret === 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfound = true\r\n\t\t\t\t\t\tcaret = index\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpossibly_last_input_character_index = index\r\n\r\n\t\t\t\t\tcaret--\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex++\r\n\t\t\t}\r\n\r\n\t\t\t// If the caret was positioned after last input character,\r\n\t\t\t// then the text caret index is just after the last input character.\r\n\t\t\tif (!found)\r\n\t\t\t{\r\n\t\t\t\tcaret = possibly_last_input_character_index + 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { text, caret }\r\n}"]},"metadata":{},"sourceType":"script"}