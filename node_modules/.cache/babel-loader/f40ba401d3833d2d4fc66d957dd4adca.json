{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp2;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _List = require('./List');\n\nvar _List2 = _interopRequireDefault(_List);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // `PureComponent` is only available in React >= 15.3.0.\n\n\nvar PureComponent = _react2.default.PureComponent || _react2.default.Component;\nvar ScrollableList = (_temp2 = _class = function (_PureComponent) {\n  _inherits(ScrollableList, _PureComponent);\n\n  function ScrollableList() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ScrollableList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScrollableList.__proto__ || Object.getPrototypeOf(ScrollableList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      // Is initialized during the first `componentDidUpdate()` call.\n      verticalPadding: 0 // Proxy `<List/>` methods.\n\n    }, _this.focusItem = function (index) {\n      return _this.list.focusItem(index);\n    }, _this.focus = function () {\n      return _this.list.focus();\n    }, _this.clearFocus = function () {\n      return _this.list.clearFocus();\n    }, _this.onListItemsChanged = function () {\n      return _this.list.onListItemsChanged();\n    }, _this.onKeyDown = function (event) {\n      return _this.list.onKeyDown(event);\n    }, _this.chooseFocusedItem = function () {\n      return _this.list.chooseFocusedItem();\n    }, _this.getFocusedItemIndex = function () {\n      return _this.list.getFocusedItemIndex();\n    }, _this.focusItem = function (index) {\n      return _this.list.focusItem(index);\n    }, _this.onFocusItem = function (index, options) {\n      var onFocusItem = _this.props.onFocusItem;\n\n      if (onFocusItem) {\n        onFocusItem(index, options);\n      } // When `<List/>` calls `.focusItem()` in `componentDidMount()`\n      // `this.list` doesn't exist yet, hence the check.\n\n\n      if (index !== undefined && _this.list) {\n        _this.showItem(index);\n      }\n    }, _this.getListNode = function () {\n      return _this.list.list;\n    }, _this.storeListRef = function (ref) {\n      return _this.list = ref;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(ScrollableList, [{\n    key: 'showItem',\n    // Fully shows an option having the `value` (scrolls to it if neccessary)\n    value: function showItem(index) {\n      var edge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n      var children = this.props.children;\n      var itemElement = this.list.itemRefs[index];\n      var isFirstItem = index === 0;\n      var isLastItem = index === _react2.default.Children.count(children) - 1;\n\n      if (isFirstItem) {\n        return this.showTopLine(itemElement, true);\n      } else if (isLastItem) {\n        return this.showBottomLine(itemElement, true);\n      }\n\n      switch (edge) {\n        case 'top':\n          return this.showTopLine(itemElement);\n\n        case 'bottom':\n          return this.showBottomLine(itemElement);\n      }\n    }\n  }, {\n    key: 'showTopLine',\n    value: function showTopLine(itemElement, isFirstItem) {\n      var verticalPadding = this.state.verticalPadding;\n      var topLine = itemElement.offsetTop;\n\n      if (isFirstItem) {\n        topLine -= verticalPadding;\n      }\n\n      if (topLine < this.getListNode().scrollTop) {\n        this.getListNode().scrollTop = topLine;\n      }\n    }\n  }, {\n    key: 'showBottomLine',\n    value: function showBottomLine(itemElement, isLastItem) {\n      var verticalPadding = this.state.verticalPadding;\n      var bottomLine = itemElement.offsetTop + itemElement.offsetHeight;\n\n      if (isLastItem) {\n        bottomLine += verticalPadding;\n      }\n\n      if (bottomLine > this.getListNode().scrollTop + this.getListNode().offsetHeight) {\n        this.getListNode().scrollTop = bottomLine - this.getListNode().offsetHeight;\n      }\n    }\n  }, {\n    key: 'itemOnClick',\n    value: function itemOnClick(value, event) {\n      var _this2 = this; // Collapse the `<Select/>`.\n      // Doing `setValue` in a callback\n      // because otherwise `setValue()` would result in\n      // updating props and calling `getDerivedStateFromProps()`\n      // which reads `autocomplete_value` which is being reset inside `.toggle()`.\n\n\n      this.expandable.collapse().then(function () {\n        return _this2.setValue(value);\n      });\n    } // Calculates height of the item list.\n\n  }, {\n    key: 'calculateHeight',\n    value: function calculateHeight() {\n      var children = this.props.children;\n      var height = this.getListNode().scrollHeight;\n      var verticalPadding = parseInt(window.getComputedStyle(this.getListNode()).paddingTop);\n      var state = {\n        height: height,\n        verticalPadding: verticalPadding // Calculate the appropriate list height.\n\n      };\n\n      if (this.isOverflown()) {\n        state.maxHeight = this.calculateScrollableListHeight(height, verticalPadding); // Update `max-height` immediately, without waiting for the next React render cycle.\n\n        this.list.getDOMNode().style.maxHeight = state.maxHeight + 'px';\n      }\n\n      this.setState(state);\n    }\n  }, {\n    key: 'calculateScrollableListHeight',\n    value: function calculateScrollableListHeight(height, verticalPadding) {\n      var _props = this.props,\n          scrollMaxItems = _props.scrollMaxItems,\n          children = _props.children; // Adding vertical padding here so that it shows `scrollMaxItems` items fully.\n      // Also gives a peek on the `scrollMaxItems + 1`th item by showing a half of it.\n      // Assumes items having equal height.\n\n      return (height - 2 * verticalPadding) * ((scrollMaxItems + 0.5) / _react2.default.Children.count(children)) + verticalPadding;\n    }\n  }, {\n    key: 'isOverflown',\n    value: function isOverflown() {\n      var _props2 = this.props,\n          scrollMaxItems = _props2.scrollMaxItems,\n          children = _props2.children;\n      return scrollMaxItems > 0 && _react2.default.Children.count(children) > scrollMaxItems;\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.calculateHeight();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          scrollBarPadding = _props3.scrollBarPadding,\n          className = _props3.className,\n          children = _props3.children,\n          rest = _objectWithoutProperties(_props3, ['scrollBarPadding', 'className', 'children']);\n\n      var maxHeight = this.state.maxHeight;\n      var listStyle = void 0; // Makes the list scrollable if it's max height is constrained.\n\n      if (maxHeight !== undefined) {\n        listStyle = {\n          maxHeight: maxHeight + 'px'\n        };\n      }\n\n      return _react2.default.createElement(_List2.default, _extends({}, rest, {\n        ref: this.storeListRef,\n        onFocusItem: this.onFocusItem,\n        style: listStyle,\n        className: (0, _classnames2.default)(className, {\n          'rrui__scrollable': this.isOverflown()\n        })\n      }), children);\n    }\n  }]);\n\n  return ScrollableList;\n}(PureComponent), _class.propTypes = {\n  // // A list of items.\n  // items : PropTypes.arrayOf\n  // (\n  // \tPropTypes.shape\n  // \t({\n  // \t\t// Item value (may be `undefined`).\n  // \t\tvalue : PropTypes.any,\n  // \t\t// Item label (may be `undefined`).\n  // \t\tlabel : PropTypes.string,\n  // \t\t// Item icon component.\n  // \t\ticon  : PropTypes.func,\n  // \t\t// Render custom content (a React component).\n  // \t\t// Receives `{ value, label }` properties.\n  // \t\tcontent : PropTypes.func\n  // \t})\n  // ),\n  // Maximum items fitting the list height (scrollable).\n  // Set to `0` to disable overflow.\n  // Is `6` by default.\n  scrollMaxItems: _propTypes2.default.number.isRequired,\n  // Whether should add `margin-right` for scrollbar width on overflow.\n  // Is `true` by default.\n  scrollBarPadding: _propTypes2.default.bool,\n  className: _propTypes2.default.string\n}, _class.defaultProps = {\n  scrollMaxItems: 6,\n  scrollBarPadding: true\n}, _temp2);\nexports.default = ScrollableList;","map":{"version":3,"sources":["../source/ScrollableList.js"],"names":["PureComponent","ScrollableList","propTypes","scrollMaxItems","scrollBarPadding","className","string","defaultProps","state","verticalPadding","focusItem","focus","clearFocus","onListItemsChanged","onKeyDown","chooseFocusedItem","getFocusedItemIndex","onFocusItem","index","getListNode","edge","children","itemElement","isFirstItem","isLastItem","topLine","bottomLine","storeListRef","value","event","height","parseInt","window","rest","maxHeight","listStyle"],"mappings":"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","sourcesContent":["import React from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport classNames from 'classnames'\r\n\r\nimport List from './List'\r\n\r\n// `PureComponent` is only available in React >= 15.3.0.\r\nconst PureComponent = React.PureComponent || React.Component\r\n\r\nexport default class ScrollableList extends PureComponent\r\n{\r\n\tstatic propTypes =\r\n\t{\r\n\t\t// // A list of items.\r\n\t\t// items : PropTypes.arrayOf\r\n\t\t// (\r\n\t\t// \tPropTypes.shape\r\n\t\t// \t({\r\n\t\t// \t\t// Item value (may be `undefined`).\r\n\t\t// \t\tvalue : PropTypes.any,\r\n\t\t// \t\t// Item label (may be `undefined`).\r\n\t\t// \t\tlabel : PropTypes.string,\r\n\t\t// \t\t// Item icon component.\r\n\t\t// \t\ticon  : PropTypes.func,\r\n\t\t// \t\t// Render custom content (a React component).\r\n\t\t// \t\t// Receives `{ value, label }` properties.\r\n\t\t// \t\tcontent : PropTypes.func\r\n\t\t// \t})\r\n\t\t// ),\r\n\r\n\t\t// Maximum items fitting the list height (scrollable).\r\n\t\t// Set to `0` to disable overflow.\r\n\t\t// Is `6` by default.\r\n\t\tscrollMaxItems : PropTypes.number.isRequired,\r\n\r\n\t\t// Whether should add `margin-right` for scrollbar width on overflow.\r\n\t\t// Is `true` by default.\r\n\t\tscrollBarPadding : PropTypes.bool,\r\n\r\n\t\tclassName : PropTypes.string\r\n\t}\r\n\r\n\tstatic defaultProps =\r\n\t{\r\n\t\tscrollMaxItems : 6,\r\n\t\tscrollBarPadding : true\r\n\t}\r\n\r\n\tstate =\r\n\t{\r\n\t\t// Is initialized during the first `componentDidUpdate()` call.\r\n\t\tverticalPadding : 0\r\n\t}\r\n\r\n\t// Proxy `<List/>` methods.\r\n\tfocusItem = (index) => this.list.focusItem(index)\r\n\tfocus = () => this.list.focus()\r\n\tclearFocus = () => this.list.clearFocus()\r\n\tonListItemsChanged = () => this.list.onListItemsChanged()\r\n\tonKeyDown = (event) => this.list.onKeyDown(event)\r\n\tchooseFocusedItem = () => this.list.chooseFocusedItem()\r\n\tgetFocusedItemIndex = () => this.list.getFocusedItemIndex()\r\n\tfocusItem = (index) => this.list.focusItem(index)\r\n\r\n\tonFocusItem = (index, options) => {\r\n\t\tconst { onFocusItem } = this.props\r\n\t\tif (onFocusItem) {\r\n\t\t\tonFocusItem(index, options)\r\n\t\t}\r\n\t\t// When `<List/>` calls `.focusItem()` in `componentDidMount()`\r\n\t\t// `this.list` doesn't exist yet, hence the check.\r\n\t\tif (index !== undefined && this.list) {\r\n\t\t\tthis.showItem(index)\r\n\t\t}\r\n\t}\r\n\r\n\tgetListNode = () => this.list.list\r\n\r\n\t// Fully shows an option having the `value` (scrolls to it if neccessary)\r\n\tshowItem(index, edge = 'top')\r\n\t{\r\n\t\tconst { children } = this.props\r\n\r\n\t\tconst itemElement = this.list.itemRefs[index]\r\n\r\n\t\tconst isFirstItem = index === 0\r\n\t\tconst isLastItem  = index === React.Children.count(children) - 1\r\n\r\n\t\tif (isFirstItem) {\r\n\t\t\treturn this.showTopLine(itemElement, true)\r\n\t\t} else if (isLastItem) {\r\n\t\t\treturn this.showBottomLine(itemElement, true)\r\n\t\t}\r\n\r\n\t\tswitch (edge)\r\n\t\t{\r\n\t\t\tcase 'top':\r\n\t\t\t\treturn this.showTopLine(itemElement)\r\n\t\t\tcase 'bottom':\r\n\t\t\t\treturn this.showBottomLine(itemElement)\r\n\t\t}\r\n\t}\r\n\r\n\tshowTopLine(itemElement, isFirstItem)\r\n\t{\r\n\t\tconst { verticalPadding } = this.state\r\n\r\n\t\tlet topLine = itemElement.offsetTop\r\n\r\n\t\tif (isFirstItem) {\r\n\t\t\ttopLine -= verticalPadding\r\n\t\t}\r\n\r\n\t\tif (topLine < this.getListNode().scrollTop) {\r\n\t\t\tthis.getListNode().scrollTop = topLine\r\n\t\t}\r\n\t}\r\n\r\n\tshowBottomLine(itemElement, isLastItem)\r\n\t{\r\n\t\tconst { verticalPadding } = this.state\r\n\r\n\t\tlet bottomLine = itemElement.offsetTop + itemElement.offsetHeight\r\n\r\n\t\tif (isLastItem) {\r\n\t\t\tbottomLine += verticalPadding\r\n\t\t}\r\n\r\n\t\tif (bottomLine > this.getListNode().scrollTop + this.getListNode().offsetHeight) {\r\n\t\t\tthis.getListNode().scrollTop = bottomLine - this.getListNode().offsetHeight\r\n\t\t}\r\n\t}\r\n\r\n\tstoreListRef = (ref) => this.list = ref\r\n\r\n\titemOnClick(value, event)\r\n\t{\r\n\t\t// Collapse the `<Select/>`.\r\n\t\t// Doing `setValue` in a callback\r\n\t\t// because otherwise `setValue()` would result in\r\n\t\t// updating props and calling `getDerivedStateFromProps()`\r\n\t\t// which reads `autocomplete_value` which is being reset inside `.toggle()`.\r\n\t\tthis.expandable.collapse().then(() => this.setValue(value))\r\n\t}\r\n\r\n\t// Calculates height of the item list.\r\n\tcalculateHeight()\r\n\t{\r\n\t\tconst { children } = this.props\r\n\r\n\t\tconst height = this.getListNode().scrollHeight\r\n\t\tconst verticalPadding = parseInt(window.getComputedStyle(this.getListNode()).paddingTop)\r\n\r\n\t\tconst state = { height, verticalPadding }\r\n\r\n\t\t// Calculate the appropriate list height.\r\n\t\tif (this.isOverflown()) {\r\n\t\t\tstate.maxHeight = this.calculateScrollableListHeight(height, verticalPadding)\r\n\t\t\t// Update `max-height` immediately, without waiting for the next React render cycle.\r\n\t\t\tthis.list.getDOMNode().style.maxHeight = state.maxHeight + 'px'\r\n\t\t}\r\n\r\n\t\tthis.setState(state)\r\n\t}\r\n\r\n\tcalculateScrollableListHeight(height, verticalPadding)\r\n\t{\r\n\t\tconst { scrollMaxItems, children } = this.props\r\n\r\n\t\t// Adding vertical padding here so that it shows `scrollMaxItems` items fully.\r\n\t\t// Also gives a peek on the `scrollMaxItems + 1`th item by showing a half of it.\r\n\t\t// Assumes items having equal height.\r\n\t\treturn (height - 2 * verticalPadding) * ((scrollMaxItems + 0.5) / React.Children.count(children)) + verticalPadding\r\n\t}\r\n\r\n\tisOverflown()\r\n\t{\r\n\t\tconst { scrollMaxItems, children } = this.props\r\n\t\treturn scrollMaxItems > 0 && React.Children.count(children) > scrollMaxItems\r\n\t}\r\n\r\n\tcomponentDidMount()\r\n\t{\r\n\t\tthis.calculateHeight()\r\n\t}\r\n\r\n\trender()\r\n\t{\r\n\t\tconst\r\n\t\t{\r\n\t\t\tscrollBarPadding,\r\n\t\t\tclassName,\r\n\t\t\tchildren,\r\n\t\t\t...rest\r\n\t\t}\r\n\t\t= this.props\r\n\r\n\t\tconst { maxHeight } = this.state\r\n\r\n\t\tlet listStyle\r\n\r\n\t\t// Makes the list scrollable if it's max height is constrained.\r\n\t\tif (maxHeight !== undefined)\r\n\t\t{\r\n\t\t\tlistStyle = { maxHeight: `${maxHeight}px` }\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\t<List\r\n\t\t\t\t{...rest}\r\n\t\t\t\tref={ this.storeListRef }\r\n\t\t\t\tonFocusItem={ this.onFocusItem }\r\n\t\t\t\tstyle={ listStyle }\r\n\t\t\t\tclassName={ classNames(className,\r\n\t\t\t\t{\r\n\t\t\t\t\t'rrui__scrollable' : this.isOverflown()\r\n\t\t\t\t}) }>\r\n\t\t\t\t{ children }\r\n\t\t\t</List>\r\n\t\t)\r\n\t}\r\n}"]},"metadata":{},"sourceType":"script"}