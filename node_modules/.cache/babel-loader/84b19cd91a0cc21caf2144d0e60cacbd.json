{"ast":null,"code":"import Metadata from './metadata';\nimport { matchesEntirely, mergeArrays } from './util';\nvar NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL']; // Finds out national phone number type (fixed line, mobile, etc)\n\nexport default function getNumberType(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var metadata = arguments[2]; // When `parse()` returned `{}`\n  // meaning that the phone number is not a valid one.\n\n  if (!input.country) {\n    return;\n  }\n\n  metadata = new Metadata(metadata);\n\n  if (!metadata.hasCountry(input.country)) {\n    throw new Error('Unknown country: ' + input.country);\n  }\n\n  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;\n  metadata.country(input.country); // The following is copy-pasted from the original function:\n  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n  // Is this national number even valid for this country\n\n  if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {\n    return;\n  } // Is it fixed line number\n\n\n  if (is_of_type(nationalNumber, 'FIXED_LINE', metadata)) {\n    // Because duplicate regular expressions are removed\n    // to reduce metadata size, if \"mobile\" pattern is \"\"\n    // then it means it was removed due to being a duplicate of the fixed-line pattern.\n    //\n    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\n      return 'FIXED_LINE_OR_MOBILE';\n    } // v1 metadata.\n    // Legacy.\n    // Deprecated.\n\n\n    if (!metadata.type('MOBILE')) {\n      return 'FIXED_LINE_OR_MOBILE';\n    } // Check if the number happens to qualify as both fixed line and mobile.\n    // (no such country in the minimal metadata set)\n\n    /* istanbul ignore if */\n\n\n    if (is_of_type(nationalNumber, 'MOBILE', metadata)) {\n      return 'FIXED_LINE_OR_MOBILE';\n    }\n\n    return 'FIXED_LINE';\n  }\n\n  for (var _iterator = NON_FIXED_LINE_PHONE_TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _type = _ref;\n\n    if (is_of_type(nationalNumber, _type, metadata)) {\n      return _type;\n    }\n  }\n}\nexport function is_of_type(nationalNumber, type, metadata) {\n  type = metadata.type(type);\n\n  if (!type || !type.pattern()) {\n    return false;\n  } // Check if any possible number lengths are present;\n  // if so, we use them to avoid checking\n  // the validation pattern if they don't match.\n  // If they are absent, this means they match\n  // the general description, which we have\n  // already checked before a specific number type.\n\n\n  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {\n    return false;\n  }\n\n  return matchesEntirely(nationalNumber, type.pattern());\n} // Should only be called for the \"new\" metadata which has \"possible lengths\".\n\nexport function checkNumberLengthForType(nationalNumber, type, metadata) {\n  var type_info = metadata.type(type); // There should always be \"<possiblePengths/>\" set for every type element.\n  // This is declared in the XML schema.\n  // For size efficiency, where a sub-description (e.g. fixed-line)\n  // has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\n  // so we fall back to the \"general description\". Where no numbers of the type\n  // exist at all, there is one possible length (-1) which is guaranteed\n  // not to match the length of any real phone number.\n\n  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths(); // let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\n\n  if (type === 'FIXED_LINE_OR_MOBILE') {\n    // No such country in metadata.\n\n    /* istanbul ignore next */\n    if (!metadata.type('FIXED_LINE')) {\n      // The rare case has been encountered where no fixedLine data is available\n      // (true for some non-geographical entities), so we just check mobile.\n      return checkNumberLengthForType(nationalNumber, 'MOBILE', metadata);\n    }\n\n    var mobile_type = metadata.type('MOBILE');\n\n    if (mobile_type) {\n      // Merge the mobile data in if there was any. \"Concat\" creates a new\n      // array, it doesn't edit possible_lengths in place, so we don't need a copy.\n      // Note that when adding the possible lengths from mobile, we have\n      // to again check they aren't empty since if they are this indicates\n      // they are the same as the general desc and should be obtained from there.\n      possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths()); // The current list is sorted; we need to merge in the new list and\n      // re-sort (duplicates are okay). Sorting isn't so expensive because\n      // the lists are very small.\n      // if (local_lengths)\n      // {\n      // \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\n      // }\n      // else\n      // {\n      // \tlocal_lengths = mobile_type.possibleLengthsLocal()\n      // }\n    }\n  } // If the type doesn't exist then return 'INVALID_LENGTH'.\n  else if (type && !type_info) {\n      return 'INVALID_LENGTH';\n    }\n\n  var actual_length = nationalNumber.length; // In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\n  // // This is safe because there is never an overlap beween the possible lengths\n  // // and the local-only lengths; this is checked at build time.\n  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\n  // {\n  // \treturn 'IS_POSSIBLE_LOCAL_ONLY'\n  // }\n\n  var minimum_length = possible_lengths[0];\n\n  if (minimum_length === actual_length) {\n    return 'IS_POSSIBLE';\n  }\n\n  if (minimum_length > actual_length) {\n    return 'TOO_SHORT';\n  }\n\n  if (possible_lengths[possible_lengths.length - 1] < actual_length) {\n    return 'TOO_LONG';\n  } // We skip the first element since we've already checked it.\n\n\n  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';\n}","map":{"version":3,"sources":["../source/getNumberType_.js"],"names":["NON_FIXED_LINE_PHONE_TYPES","options","metadata","input","nationalNumber","matchesEntirely","is_of_type","_type","type","type_info","possible_lengths","checkNumberLengthForType","mobile_type","mergeArrays","actual_length","minimum_length"],"mappings":"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","sourcesContent":["import Metadata from './metadata'\r\nimport { matchesEntirely, mergeArrays } from './util'\r\n\r\nconst NON_FIXED_LINE_PHONE_TYPES =\r\n[\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function getNumberType(input, options = {}, metadata)\r\n{\r\n\t// When `parse()` returned `{}`\r\n\t// meaning that the phone number is not a valid one.\r\n\tif (!input.country)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (!metadata.hasCountry(input.country))\r\n\t{\r\n\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t}\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\tmetadata.country(input.country)\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()))\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (is_of_type(nationalNumber, 'FIXED_LINE', metadata))\r\n\t{\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '')\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// v1 metadata.\r\n\t\t// Legacy.\r\n\t\t// Deprecated.\r\n\t\tif (!metadata.type('MOBILE'))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (is_of_type(nationalNumber, 'MOBILE', metadata))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const _type of NON_FIXED_LINE_PHONE_TYPES)\r\n\t{\r\n\t\tif (is_of_type(nationalNumber, _type, metadata))\r\n\t\t{\r\n\t\t\treturn _type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function is_of_type(nationalNumber, type, metadata)\r\n{\r\n\ttype = metadata.type(type)\r\n\r\n\tif (!type || !type.pattern())\r\n\t{\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0)\r\n\t{\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn matchesEntirely(nationalNumber, type.pattern())\r\n}\r\n\r\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\r\nexport function checkNumberLengthForType(nationalNumber, type, metadata)\r\n{\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE')\r\n\t{\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE'))\r\n\t\t{\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographical entities), so we just check mobile.\r\n\t\t\treturn checkNumberLengthForType(nationalNumber, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\r\n\t\tif (mobile_type)\r\n\t\t{\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths)\r\n\t\t\t// {\r\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// }\r\n\t\t\t// else\r\n\t\t\t// {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info)\r\n\t{\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length)\r\n\t{\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length)\r\n\t{\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length)\r\n\t{\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}"]},"metadata":{},"sourceType":"module"}